{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.web3Enable = web3Enable;\nexports.web3Accounts = web3Accounts;\nexports.web3AccountsSubscribe = web3AccountsSubscribe;\nexports.web3FromSource = web3FromSource;\nexports.web3FromAddress = web3FromAddress;\nexports.web3ListRpcProviders = web3ListRpcProviders;\nexports.web3UseRpcProvider = web3UseRpcProvider;\nexports.web3EnablePromise = exports.isWeb3Injected = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _util = require(\"./util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // just a helper (otherwise we cast all-over, so shorter and more readable)\n\n\nvar win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(\"\".concat(method, \": web3Enable(originName) needs to be called before \").concat(method));\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(function (_ref) {\n    var address = _ref.address,\n        genesisHash = _ref.genesisHash,\n        name = _ref.name;\n    var encodedAddress = (0, _utilCrypto.encodeAddress)((0, _utilCrypto.decodeAddress)(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash: genesisHash,\n        name: name,\n        source: source\n      }\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nvar isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nexports.isWeb3Injected = isWeb3Injected;\nvar web3EnablePromise = null;\nexports.web3EnablePromise = web3EnablePromise; // enables all the providers found on the injected window interface\n\nfunction web3Enable(originName) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  exports.web3EnablePromise = web3EnablePromise = (0, _util.documentReadyPromise)(function () {\n    return Promise.all(Object.entries(win.injectedWeb3).map(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          name = _ref3[0],\n          _ref3$ = _ref3[1],\n          enable = _ref3$.enable,\n          version = _ref3$.version;\n\n      return Promise.all([Promise.resolve({\n        name: name,\n        version: version\n      }), enable(originName).catch(function (error) {\n        console.error(\"Error initializing \".concat(name, \": \").concat(error.message));\n      })]);\n    })).then(function (values) {\n      return values.filter(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            ext = _ref5[1];\n\n        return !!ext;\n      }).map(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            info = _ref7[0],\n            ext = _ref7[1];\n\n        // if we don't have an accounts subscriber, add a single-shot version\n        if (ext && !ext.accounts.subscribe) {\n          ext.accounts.subscribe = function (cb) {\n            ext.accounts.get().then(cb).catch(console.error);\n            return function () {// no ubsubscribe needed, this is a single-shot\n            };\n          };\n        }\n\n        var injected = _objectSpread(_objectSpread({}, info), ext);\n\n        return injected;\n      });\n    }).catch(function () {\n      return [];\n    }).then(function (values) {\n      var names = values.map(function (_ref8) {\n        var name = _ref8.name,\n            version = _ref8.version;\n        return \"\".concat(name, \"/\").concat(version);\n      });\n      exports.isWeb3Injected = isWeb3Injected = web3IsInjected();\n      console.log(\"web3Enable: Enabled \".concat(values.length, \" extension\").concat(values.length !== 1 ? 's' : '', \": \").concat(names.join(', ')));\n      return values;\n    });\n  });\n  return web3EnablePromise;\n} // retrieve all the accounts accross all providers\n\n\nfunction web3Accounts() {\n  return _web3Accounts.apply(this, arguments);\n}\n\nfunction _web3Accounts() {\n  _web3Accounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var _ref9,\n        ss58Format,\n        accounts,\n        injected,\n        retrieved,\n        addresses,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref9 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, ss58Format = _ref9.ss58Format;\n\n            if (web3EnablePromise) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", throwError('web3Accounts'));\n\n          case 3:\n            accounts = [];\n            _context2.next = 6;\n            return web3EnablePromise;\n\n          case 6:\n            injected = _context2.sent;\n            _context2.next = 9;\n            return Promise.all(injected.map( /*#__PURE__*/function () {\n              var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref10) {\n                var accounts, source, list;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        accounts = _ref10.accounts, source = _ref10.name;\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return accounts.get();\n\n                      case 4:\n                        list = _context.sent;\n                        return _context.abrupt(\"return\", mapAccounts(source, list, ss58Format));\n\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context[\"catch\"](1);\n                        return _context.abrupt(\"return\", []);\n\n                      case 11:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 8]]);\n              }));\n\n              return function (_x7) {\n                return _ref11.apply(this, arguments);\n              };\n            }()));\n\n          case 9:\n            retrieved = _context2.sent;\n            retrieved.forEach(function (result) {\n              accounts.push.apply(accounts, _toConsumableArray(result));\n            });\n            addresses = accounts.map(function (_ref12) {\n              var address = _ref12.address;\n              return address;\n            });\n            console.log(\"web3Accounts: Found \".concat(accounts.length, \" address\").concat(accounts.length !== 1 ? 'es' : '', \": \").concat(addresses.join(', ')));\n            return _context2.abrupt(\"return\", accounts);\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _web3Accounts.apply(this, arguments);\n}\n\nfunction web3AccountsSubscribe(_x) {\n  return _web3AccountsSubscribe.apply(this, arguments);\n} // find a specific provider based on the name\n\n\nfunction _web3AccountsSubscribe() {\n  _web3AccountsSubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(cb) {\n    var _ref13,\n        ss58Format,\n        accounts,\n        triggerUpdate,\n        unsubs,\n        _args3 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _ref13 = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {}, ss58Format = _ref13.ss58Format;\n\n            if (web3EnablePromise) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", throwError('web3AccountsSubscribe'));\n\n          case 3:\n            accounts = {};\n\n            triggerUpdate = function triggerUpdate() {\n              return cb(Object.entries(accounts).reduce(function (result, _ref14) {\n                var _ref15 = _slicedToArray(_ref14, 2),\n                    source = _ref15[0],\n                    list = _ref15[1];\n\n                result.push.apply(result, _toConsumableArray(mapAccounts(source, list, ss58Format)));\n                return result;\n              }, []));\n            };\n\n            _context3.next = 7;\n            return web3EnablePromise;\n\n          case 7:\n            unsubs = _context3.sent.map(function (_ref16) {\n              var subscribe = _ref16.accounts.subscribe,\n                  source = _ref16.name;\n              return subscribe(function (result) {\n                accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n                triggerUpdate();\n              });\n            });\n            return _context3.abrupt(\"return\", function () {\n              unsubs.forEach(function (unsub) {\n                unsub();\n              });\n            });\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _web3AccountsSubscribe.apply(this, arguments);\n}\n\nfunction web3FromSource(_x2) {\n  return _web3FromSource.apply(this, arguments);\n} // find a specific provider based on an address\n\n\nfunction _web3FromSource() {\n  _web3FromSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(source) {\n    var sources, found;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (web3EnablePromise) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", throwError('web3FromSource'));\n\n          case 2:\n            _context4.next = 4;\n            return web3EnablePromise;\n\n          case 4:\n            sources = _context4.sent;\n            found = source && sources.find(function (_ref17) {\n              var name = _ref17.name;\n              return name === source;\n            });\n\n            if (found) {\n              _context4.next = 8;\n              break;\n            }\n\n            throw new Error(\"web3FromSource: Unable to find an injected \".concat(source));\n\n          case 8:\n            return _context4.abrupt(\"return\", found);\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _web3FromSource.apply(this, arguments);\n}\n\nfunction web3FromAddress(_x3) {\n  return _web3FromAddress.apply(this, arguments);\n} // retrieve all providers exposed by one source\n\n\nfunction _web3FromAddress() {\n  _web3FromAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n    var accounts, found;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (web3EnablePromise) {\n              _context5.next = 2;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", throwError('web3FromAddress'));\n\n          case 2:\n            _context5.next = 4;\n            return web3Accounts();\n\n          case 4:\n            accounts = _context5.sent;\n            found = address && accounts.find(function (account) {\n              return account.address === address;\n            });\n\n            if (found) {\n              _context5.next = 8;\n              break;\n            }\n\n            throw new Error(\"web3FromAddress: Unable to find injected \".concat(address));\n\n          case 8:\n            return _context5.abrupt(\"return\", web3FromSource(found.meta.source));\n\n          case 9:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _web3FromAddress.apply(this, arguments);\n}\n\nfunction web3ListRpcProviders(_x4) {\n  return _web3ListRpcProviders.apply(this, arguments);\n} // retrieve all providers exposed by one source\n\n\nfunction _web3ListRpcProviders() {\n  _web3ListRpcProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(source) {\n    var _yield$web3FromSource, provider;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return web3FromSource(source);\n\n          case 2:\n            _yield$web3FromSource = _context6.sent;\n            provider = _yield$web3FromSource.provider;\n\n            if (provider) {\n              _context6.next = 7;\n              break;\n            }\n\n            console.warn(\"Extension \".concat(source, \" does not expose any provider\"));\n            return _context6.abrupt(\"return\", null);\n\n          case 7:\n            return _context6.abrupt(\"return\", provider.listProviders());\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _web3ListRpcProviders.apply(this, arguments);\n}\n\nfunction web3UseRpcProvider(_x5, _x6) {\n  return _web3UseRpcProvider.apply(this, arguments);\n}\n\nfunction _web3UseRpcProvider() {\n  _web3UseRpcProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(source, key) {\n    var _yield$web3FromSource2, provider, meta;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return web3FromSource(source);\n\n          case 2:\n            _yield$web3FromSource2 = _context7.sent;\n            provider = _yield$web3FromSource2.provider;\n\n            if (provider) {\n              _context7.next = 6;\n              break;\n            }\n\n            throw new Error(\"Extension \".concat(source, \" does not expose any provider\"));\n\n          case 6:\n            _context7.next = 8;\n            return provider.startProvider(key);\n\n          case 8:\n            meta = _context7.sent;\n            return _context7.abrupt(\"return\", {\n              meta: meta,\n              provider: provider\n            });\n\n          case 10:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _web3UseRpcProvider.apply(this, arguments);\n}","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/extension-dapp/index.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","web3Enable","web3Accounts","web3AccountsSubscribe","web3FromSource","web3FromAddress","web3ListRpcProviders","web3UseRpcProvider","web3EnablePromise","isWeb3Injected","_defineProperty2","_utilCrypto","_util","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","default","getOwnPropertyDescriptors","defineProperties","win","window","injectedWeb3","web3IsInjected","throwError","method","Error","mapAccounts","list","ss58Format","map","address","genesisHash","name","encodedAddress","encodeAddress","decodeAddress","meta","originName","documentReadyPromise","Promise","all","entries","enable","version","resolve","catch","error","console","message","then","values","ext","info","accounts","subscribe","cb","get","injected","names","log","join","retrieved","result","addresses","triggerUpdate","reduce","unsubs","unsub","sources","found","find","account","provider","warn","listProviders","startProvider"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.web3Enable = web3Enable;\nexports.web3Accounts = web3Accounts;\nexports.web3AccountsSubscribe = web3AccountsSubscribe;\nexports.web3FromSource = web3FromSource;\nexports.web3FromAddress = web3FromAddress;\nexports.web3ListRpcProviders = web3ListRpcProviders;\nexports.web3UseRpcProvider = web3UseRpcProvider;\nexports.web3EnablePromise = exports.isWeb3Injected = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _util = require(\"./util\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// just a helper (otherwise we cast all-over, so shorter and more readable)\nconst win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(({\n    address,\n    genesisHash,\n    name\n  }) => {\n    const encodedAddress = (0, _utilCrypto.encodeAddress)((0, _utilCrypto.decodeAddress)(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash,\n        name,\n        source\n      }\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nlet isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nexports.isWeb3Injected = isWeb3Injected;\nlet web3EnablePromise = null;\nexports.web3EnablePromise = web3EnablePromise;\n\n// enables all the providers found on the injected window interface\nfunction web3Enable(originName) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  exports.web3EnablePromise = web3EnablePromise = (0, _util.documentReadyPromise)(() => Promise.all(Object.entries(win.injectedWeb3).map(([name, {\n    enable,\n    version\n  }]) => {\n    return Promise.all([Promise.resolve({\n      name,\n      version\n    }), enable(originName).catch(error => {\n      console.error(`Error initializing ${name}: ${error.message}`);\n    })]);\n  })).then(values => values.filter(([, ext]) => !!ext).map(([info, ext]) => {\n    // if we don't have an accounts subscriber, add a single-shot version\n    if (ext && !ext.accounts.subscribe) {\n      ext.accounts.subscribe = cb => {\n        ext.accounts.get().then(cb).catch(console.error);\n        return () => {// no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n\n    const injected = _objectSpread(_objectSpread({}, info), ext);\n\n    return injected;\n  })).catch(() => []).then(values => {\n    const names = values.map(({\n      name,\n      version\n    }) => `${name}/${version}`);\n    exports.isWeb3Injected = isWeb3Injected = web3IsInjected();\n    console.log(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n    return values;\n  }));\n  return web3EnablePromise;\n} // retrieve all the accounts accross all providers\n\n\nasync function web3Accounts({\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3Accounts');\n  }\n\n  const accounts = [];\n  const injected = await web3EnablePromise;\n  const retrieved = await Promise.all(injected.map(async ({\n    accounts,\n    name: source\n  }) => {\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, list, ss58Format);\n    } catch (error) {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  const addresses = accounts.map(({\n    address\n  }) => address);\n  console.log(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}: ${addresses.join(', ')}`);\n  return accounts;\n}\n\nasync function web3AccountsSubscribe(cb, {\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3AccountsSubscribe');\n  }\n\n  const accounts = {};\n\n  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {\n    result.push(...mapAccounts(source, list, ss58Format));\n    return result;\n  }, []));\n\n  const unsubs = (await web3EnablePromise).map(({\n    accounts: {\n      subscribe\n    },\n    name: source\n  }) => subscribe(result => {\n    accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    triggerUpdate();\n  }));\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n} // find a specific provider based on the name\n\n\nasync function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(({\n    name\n  }) => name === source);\n\n  if (!found) {\n    throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n  }\n\n  return found;\n} // find a specific provider based on an address\n\n\nasync function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n\n  const accounts = await web3Accounts();\n  const found = address && accounts.find(account => account.address === address);\n\n  if (!found) {\n    throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n  }\n\n  return web3FromSource(found.meta.source);\n} // retrieve all providers exposed by one source\n\n\nasync function web3ListRpcProviders(source) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    console.warn(`Extension ${source} does not expose any provider`);\n    return null;\n  }\n\n  return provider.listProviders();\n} // retrieve all providers exposed by one source\n\n\nasync function web3UseRpcProvider(source, key) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    throw new Error(`Extension ${source} does not expose any provider`);\n  }\n\n  const meta = await provider.startProvider(key);\n  return {\n    meta,\n    provider\n  };\n}"]},"metadata":{},"sourceType":"script"}