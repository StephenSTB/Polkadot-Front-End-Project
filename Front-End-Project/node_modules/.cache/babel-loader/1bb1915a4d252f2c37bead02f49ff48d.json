{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toLatest;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\n\n\nvar KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n}; // TODO Handle consts as well\n\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, type) {\n  var override = Object.keys(sectionTypes).find(function (aliased) {\n    return type.eq(aliased);\n  });\n\n  if (override) {\n    type.setOverride(sectionTypes[override]);\n  } else {\n    // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n    var orig = type.toString();\n    var alias = Object.entries(sectionTypes).reduce(function (result, _ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          from = _ref2[0],\n          to = _ref2[1];\n\n      return [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce(function (result, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            one = _ref4[0],\n            two = _ref4[1];\n\n        return result.replace(\"\".concat(one).concat(from).concat(two), \"\".concat(one).concat(to).concat(two));\n      }, result);\n    }, orig);\n\n    if (orig !== alias) {\n      type.setOverride(alias);\n    }\n  }\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(function (_ref5) {\n    var args = _ref5.args,\n        documentation = _ref5.documentation,\n        name = _ref5.name;\n    args.forEach(function (_ref6) {\n      var type = _ref6.type;\n      return setTypeOverride(sectionTypes, type);\n    });\n    return registry.createType('FunctionMetadataLatest', {\n      args: args,\n      documentation: documentation,\n      name: name\n    });\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(function (_ref7) {\n    var args = _ref7.args,\n        documentation = _ref7.documentation,\n        name = _ref7.name;\n    args.forEach(function (type) {\n      return setTypeOverride(sectionTypes, type);\n    });\n    return registry.createType('EventMetadataLatest', {\n      args: args,\n      documentation: documentation,\n      name: name\n    });\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, _ref8, sectionTypes) {\n  var items = _ref8.items,\n      prefix = _ref8.prefix;\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(function (_ref9) {\n      var documentation = _ref9.documentation,\n          fallback = _ref9.fallback,\n          modifier = _ref9.modifier,\n          name = _ref9.name,\n          type = _ref9.type;\n      var resultType;\n\n      if (type.isMap) {\n        resultType = type.asMap.value;\n      } else if (type.isDoubleMap) {\n        resultType = type.asDoubleMap.value;\n      } else {\n        resultType = type.asPlain;\n      }\n\n      setTypeOverride(sectionTypes, resultType);\n      return registry.createType('StorageEntryMetadataLatest', {\n        documentation: documentation,\n        fallback: fallback,\n        modifier: modifier,\n        name: name,\n        type: type\n      });\n    }),\n    prefix: prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules) {\n  var isIndexed = modules.some(function (_ref10) {\n    var index = _ref10.index;\n    return !index.eqn(255);\n  });\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map(function (mod, index) {\n        return [mod.name.toString(), isIndexed ? mod.index.toNumber() : index];\n      }).sort(function (a, b) {\n        return a[1] - b[1];\n      }).reduce(function (result, _ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n            name = _ref12[0],\n            index = _ref12[1];\n\n        for (var i = Object.keys(result).length; i < index; i++) {\n          result[\"Empty\".concat(i)] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nfunction toLatest(registry, _ref13) {\n  var extrinsic = _ref13.extrinsic,\n      modules = _ref13.modules;\n  registerOriginCaller(registry, modules);\n  return registry.createType('MetadataLatest', {\n    extrinsic: extrinsic,\n    modules: modules.map(function (mod) {\n      var calls = mod.calls.unwrapOr(null);\n      var events = mod.events.unwrapOr(null);\n      var storage = mod.storage.unwrapOr(null);\n      var sectionTypes = (0, _typesKnown.getModuleTypes)(registry, (0, _util.stringCamelCase)(mod.name.toString()));\n      return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n        calls: calls ? convertCalls(registry, calls, sectionTypes) : null,\n        events: events ? convertEvents(registry, events, sectionTypes) : null,\n        storage: storage ? convertStorage(registry, storage, sectionTypes) : null\n      }));\n    })\n  });\n}","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/metadata/Metadata/v12/toLatest.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","toLatest","_defineProperty2","_typesKnown","_util","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","KNOWN_ORIGINS","Council","System","TechnicalCommittee","setTypeOverride","sectionTypes","type","override","find","aliased","eq","setOverride","orig","toString","alias","entries","reduce","result","from","to","one","two","replace","convertCalls","registry","calls","map","args","documentation","name","createType","convertEvents","events","convertStorage","items","prefix","fallback","modifier","resultType","isMap","asMap","isDoubleMap","asDoubleMap","asPlain","registerOriginCaller","modules","isIndexed","some","index","eqn","register","OriginCaller","_enum","mod","toNumber","sort","a","b","extrinsic","unwrapOr","storage","getModuleTypes","stringCamelCase"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toLatest;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\nconst KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n}; // TODO Handle consts as well\n\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, type) {\n  const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n  if (override) {\n    type.setOverride(sectionTypes[override]);\n  } else {\n    // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n    const orig = type.toString();\n    const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);\n\n    if (orig !== alias) {\n      type.setOverride(alias);\n    }\n  }\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(({\n    args,\n    documentation,\n    name\n  }) => {\n    args.forEach(({\n      type\n    }) => setTypeOverride(sectionTypes, type));\n    return registry.createType('FunctionMetadataLatest', {\n      args,\n      documentation,\n      name\n    });\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(({\n    args,\n    documentation,\n    name\n  }) => {\n    args.forEach(type => setTypeOverride(sectionTypes, type));\n    return registry.createType('EventMetadataLatest', {\n      args,\n      documentation,\n      name\n    });\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(({\n      documentation,\n      fallback,\n      modifier,\n      name,\n      type\n    }) => {\n      let resultType;\n\n      if (type.isMap) {\n        resultType = type.asMap.value;\n      } else if (type.isDoubleMap) {\n        resultType = type.asDoubleMap.value;\n      } else {\n        resultType = type.asPlain;\n      }\n\n      setTypeOverride(sectionTypes, resultType);\n      return registry.createType('StorageEntryMetadataLatest', {\n        documentation,\n        fallback,\n        modifier,\n        name,\n        type\n      });\n    }),\n    prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules) {\n  const isIndexed = modules.some(({\n    index\n  }) => !index.eqn(255));\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), isIndexed ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nfunction toLatest(registry, {\n  extrinsic,\n  modules\n}) {\n  registerOriginCaller(registry, modules);\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => {\n      const calls = mod.calls.unwrapOr(null);\n      const events = mod.events.unwrapOr(null);\n      const storage = mod.storage.unwrapOr(null);\n      const sectionTypes = (0, _typesKnown.getModuleTypes)(registry, (0, _util.stringCamelCase)(mod.name.toString()));\n      return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n        calls: calls ? convertCalls(registry, calls, sectionTypes) : null,\n        events: events ? convertEvents(registry, events, sectionTypes) : null,\n        storage: storage ? convertStorage(registry, storage, sectionTypes) : null\n      }));\n    })\n  });\n}"]},"metadata":{},"sourceType":"script"}