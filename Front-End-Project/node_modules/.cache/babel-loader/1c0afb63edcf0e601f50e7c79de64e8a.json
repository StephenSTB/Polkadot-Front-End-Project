{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MortalEra = exports.ImmortalEra = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Enum = _interopRequireDefault(require(\"../codec/Enum\"));\n\nvar _Tuple = _interopRequireDefault(require(\"../codec/Tuple\"));\n\nvar _Raw = _interopRequireDefault(require(\"../codec/Raw\"));\n\nvar _U = _interopRequireDefault(require(\"../primitive/U64\"));\n\nvar _constants = require(\"./constants\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction getTrailingZeros(period) {\n  var binary = period.toString(2);\n  var index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nvar ImmortalEra = /*#__PURE__*/function (_Raw$default) {\n  _inherits(ImmortalEra, _Raw$default);\n\n  var _super = _createSuper(ImmortalEra);\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function ImmortalEra(registry, value) {\n    _classCallCheck(this, ImmortalEra);\n\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    return _super.call(this, registry, _constants.IMMORTAL_ERA);\n  }\n\n  return ImmortalEra;\n}(_Raw.default);\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\n\nexports.ImmortalEra = ImmortalEra;\n\nvar MortalEra = /*#__PURE__*/function (_Tuple$default) {\n  _inherits(MortalEra, _Tuple$default);\n\n  var _super2 = _createSuper(MortalEra);\n\n  function MortalEra(registry, value) {\n    _classCallCheck(this, MortalEra);\n\n    return _super2.call(this, registry, {\n      period: _U.default,\n      phase: _U.default\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  _createClass(MortalEra, [{\n    key: \"toHuman\",\n\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    value: function toHuman() {\n      return {\n        period: (0, _util.formatNumber)(this.period),\n        phase: (0, _util.formatNumber)(this.phase)\n      };\n    }\n    /**\n     * @description Returns a JSON representation of the actual value\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toHex();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     * Period and phase are encoded:\n     *   - The period of validity from the block hash found in the signing material.\n     *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n     *     implies which block hash is included in the signature material). If the `period` is\n     *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n     *     `period` is.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      var period = this.period.toNumber();\n      var phase = this.phase.toNumber();\n      var quantizeFactor = Math.max(period >> 12, 1);\n      var trailingZeros = getTrailingZeros(period);\n      var encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n      var first = encoded >> 8;\n      var second = encoded & 0xff;\n      return new Uint8Array([second, first]);\n    }\n    /**\n     * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n     */\n\n  }, {\n    key: \"birth\",\n    value: function birth(current) {\n      // FIXME No toNumber() here\n      return Math.floor((Math.max((0, _util.bnToBn)(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n    }\n    /**\n     * @description Get the block number of the first block at which the era has ended.\n     */\n\n  }, {\n    key: \"death\",\n    value: function death(current) {\n      // FIXME No toNumber() here\n      return this.birth(current) + this.period.toNumber();\n    }\n  }, {\n    key: \"encodedLength\",\n\n    /**\n     * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n     */\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @description The period of this Mortal wraps as a [[U64]]\n     */\n\n  }, {\n    key: \"period\",\n    get: function get() {\n      return this[0];\n    }\n    /**\n     * @description The phase of this Mortal wraps as a [[U64]]\n     */\n\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this[1];\n    }\n  }], [{\n    key: \"_decodeMortalEra\",\n    value: function _decodeMortalEra(registry, value) {\n      if ((0, _util.isHex)(value)) {\n        return MortalEra._decodeMortalU8a(registry, (0, _util.hexToU8a)(value));\n      } else if (Array.isArray(value)) {\n        return MortalEra._decodeMortalU8a(registry, new Uint8Array(value));\n      } else if ((0, _util.isU8a)(value)) {\n        return MortalEra._decodeMortalU8a(registry, value);\n      } else if ((0, _util.isObject)(value)) {\n        return MortalEra._decodeMortalObject(registry, value);\n      } else if (!value) {\n        return [new _U.default(registry), new _U.default(registry)];\n      }\n\n      throw new Error('Invalid data passed to Mortal era');\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeMortalObject\",\n    value: function _decodeMortalObject(registry, value) {\n      var current = value.current,\n          period = value.period;\n      var calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n      calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n      var phase = current % calPeriod;\n      var quantizeFactor = Math.max(calPeriod >> 12, 1);\n      var quantizedPhase = phase / quantizeFactor * quantizeFactor;\n      return [new _U.default(registry, calPeriod), new _U.default(registry, quantizedPhase)];\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeMortalU8a\",\n    value: function _decodeMortalU8a(registry, value) {\n      if (value.length === 0) {\n        return [new _U.default(registry), new _U.default(registry)];\n      }\n\n      var first = (0, _util.u8aToBn)(value.subarray(0, 1)).toNumber();\n      var second = (0, _util.u8aToBn)(value.subarray(1, 2)).toNumber();\n      var encoded = first + (second << 8);\n      var period = 2 << encoded % (1 << 4);\n      var quantizeFactor = Math.max(period >> 12, 1);\n      var phase = (encoded >> 4) * quantizeFactor;\n      (0, _util.assert)(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n      return [new _U.default(registry, period), new _U.default(registry, phase)];\n    }\n  }]);\n\n  return MortalEra;\n}(_Tuple.default);\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\n\nexports.MortalEra = MortalEra;\n\nvar ExtrinsicEra = /*#__PURE__*/function (_Enum$default) {\n  _inherits(ExtrinsicEra, _Enum$default);\n\n  var _super3 = _createSuper(ExtrinsicEra);\n\n  function ExtrinsicEra(registry, value) {\n    _classCallCheck(this, ExtrinsicEra);\n\n    return _super3.call(this, registry, {\n      ImmortalEra: ImmortalEra,\n      MortalEra: MortalEra\n    }, ExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  _createClass(ExtrinsicEra, [{\n    key: \"toU8a\",\n\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    value: function toU8a(isBare) {\n      return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n    }\n  }, {\n    key: \"encodedLength\",\n\n    /**\n     * @description Override the encoded length method\n     */\n    get: function get() {\n      return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n    }\n    /**\n     * @description Returns the item as a [[ImmortalEra]]\n     */\n\n  }, {\n    key: \"asImmortalEra\",\n    get: function get() {\n      (0, _util.assert)(this.isImmortalEra, \"Cannot convert '\".concat(this.type, \"' via asImmortalEra\"));\n      return this.value;\n    }\n    /**\n     * @description Returns the item as a [[MortalEra]]\n     */\n\n  }, {\n    key: \"asMortalEra\",\n    get: function get() {\n      (0, _util.assert)(this.isMortalEra, \"Cannot convert '\".concat(this.type, \"' via asMortalEra\"));\n      return this.value;\n    }\n    /**\n     * @description `true` if Immortal\n     */\n\n  }, {\n    key: \"isImmortalEra\",\n    get: function get() {\n      return this.index === 0;\n    }\n    /**\n     * @description `true` if Mortal\n     */\n\n  }, {\n    key: \"isMortalEra\",\n    get: function get() {\n      return this.index > 0;\n    }\n  }], [{\n    key: \"_decodeExtrinsicEra\",\n    value: function _decodeExtrinsicEra() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n\n      if (value instanceof ExtrinsicEra) {\n        return ExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n      } else if ((0, _util.isHex)(value)) {\n        return ExtrinsicEra._decodeExtrinsicEra((0, _util.hexToU8a)(value));\n      } else if (!value || (0, _util.isU8a)(value)) {\n        return !(value === null || value === void 0 ? void 0 : value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n      } else if ((0, _util.isObject)(value)) {\n        // this is to de-serialize from JSON\n        return value.MortalEra ? {\n          MortalEra: value.MortalEra\n        } : value.ImmortalEra ? {\n          ImmortalEra: value.ImmortalEra\n        } : {\n          MortalEra: value\n        };\n      }\n\n      throw new Error('Invalid data passed to Era');\n    }\n  }]);\n\n  return ExtrinsicEra;\n}(_Enum.default);\n\nexports.default = ExtrinsicEra;","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","MortalEra","ImmortalEra","_util","_Enum","_Tuple","_Raw","_U","_constants","getTrailingZeros","period","binary","toString","index","length","registry","IMMORTAL_ERA","phase","_decodeMortalEra","formatNumber","toHex","isBare","toNumber","quantizeFactor","Math","max","trailingZeros","encoded","min","first","second","Uint8Array","current","floor","bnToBn","birth","isHex","_decodeMortalU8a","hexToU8a","Array","isArray","isU8a","isObject","_decodeMortalObject","Error","calPeriod","pow","ceil","log2","quantizedPhase","u8aToBn","subarray","assert","ExtrinsicEra","_decodeExtrinsicEra","isMortalEra","asMortalEra","toU8a","asImmortalEra","isImmortalEra","encodedLength","type"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MortalEra = exports.ImmortalEra = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Enum = _interopRequireDefault(require(\"../codec/Enum\"));\n\nvar _Tuple = _interopRequireDefault(require(\"../codec/Tuple\"));\n\nvar _Raw = _interopRequireDefault(require(\"../codec/Raw\"));\n\nvar _U = _interopRequireDefault(require(\"../primitive/U64\"));\n\nvar _constants = require(\"./constants\");\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction getTrailingZeros(period) {\n  const binary = period.toString(2);\n  let index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nclass ImmortalEra extends _Raw.default {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(registry, value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(registry, _constants.IMMORTAL_ERA);\n  }\n\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\n\nexports.ImmortalEra = ImmortalEra;\n\nclass MortalEra extends _Tuple.default {\n  constructor(registry, value) {\n    super(registry, {\n      period: _U.default,\n      phase: _U.default\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeMortalEra(registry, value) {\n    if ((0, _util.isHex)(value)) {\n      return MortalEra._decodeMortalU8a(registry, (0, _util.hexToU8a)(value));\n    } else if (Array.isArray(value)) {\n      return MortalEra._decodeMortalU8a(registry, new Uint8Array(value));\n    } else if ((0, _util.isU8a)(value)) {\n      return MortalEra._decodeMortalU8a(registry, value);\n    } else if ((0, _util.isObject)(value)) {\n      return MortalEra._decodeMortalObject(registry, value);\n    } else if (!value) {\n      return [new _U.default(registry), new _U.default(registry)];\n    }\n\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  /** @internal */\n\n\n  static _decodeMortalObject(registry, value) {\n    const {\n      current,\n      period\n    } = value;\n    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n    const phase = current % calPeriod;\n    const quantizeFactor = Math.max(calPeriod >> 12, 1);\n    const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n    return [new _U.default(registry, calPeriod), new _U.default(registry, quantizedPhase)];\n  }\n  /** @internal */\n\n\n  static _decodeMortalU8a(registry, value) {\n    if (value.length === 0) {\n      return [new _U.default(registry), new _U.default(registry)];\n    }\n\n    const first = (0, _util.u8aToBn)(value.subarray(0, 1)).toNumber();\n    const second = (0, _util.u8aToBn)(value.subarray(1, 2)).toNumber();\n    const encoded = first + (second << 8);\n    const period = 2 << encoded % (1 << 4);\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const phase = (encoded >> 4) * quantizeFactor;\n    (0, _util.assert)(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n    return [new _U.default(registry, period), new _U.default(registry, phase)];\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n\n\n  get encodedLength() {\n    return 2;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n\n\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n\n\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return {\n      period: (0, _util.formatNumber)(this.period),\n      phase: (0, _util.formatNumber)(this.phase)\n    };\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    const period = this.period.toNumber();\n    const phase = this.phase.toNumber();\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const trailingZeros = getTrailingZeros(period);\n    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n    const first = encoded >> 8;\n    const second = encoded & 0xff;\n    return new Uint8Array([second, first]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n\n\n  birth(current) {\n    // FIXME No toNumber() here\n    return Math.floor((Math.max((0, _util.bnToBn)(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n\n\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\n\nexports.MortalEra = MortalEra;\n\nclass ExtrinsicEra extends _Enum.default {\n  constructor(registry, value) {\n    super(registry, {\n      ImmortalEra,\n      MortalEra\n    }, ExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  static _decodeExtrinsicEra(value = new Uint8Array()) {\n    if (value instanceof ExtrinsicEra) {\n      return ExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n    } else if ((0, _util.isHex)(value)) {\n      return ExtrinsicEra._decodeExtrinsicEra((0, _util.hexToU8a)(value));\n    } else if (!value || (0, _util.isU8a)(value)) {\n      return !(value === null || value === void 0 ? void 0 : value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n    } else if ((0, _util.isObject)(value)) {\n      // this is to de-serialize from JSON\n      return value.MortalEra ? {\n        MortalEra: value.MortalEra\n      } : value.ImmortalEra ? {\n        ImmortalEra: value.ImmortalEra\n      } : {\n        MortalEra: value\n      };\n    }\n\n    throw new Error('Invalid data passed to Era');\n  }\n  /**\n   * @description Override the encoded length method\n   */\n\n\n  get encodedLength() {\n    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n\n\n  get asImmortalEra() {\n    (0, _util.assert)(this.isImmortalEra, `Cannot convert '${this.type}' via asImmortalEra`);\n    return this.value;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n\n\n  get asMortalEra() {\n    (0, _util.assert)(this.isMortalEra, `Cannot convert '${this.type}' via asMortalEra`);\n    return this.value;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n\n\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n\n\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n\n}\n\nexports.default = ExtrinsicEra;"]},"metadata":{},"sourceType":"script"}