{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar EMPTY_U8A = new Uint8Array([]);\n\nvar NULL_HASHER = function NULL_HASHER(value) {\n  return value;\n}; // with the prefix, method & options, create both the string & raw keys\n\n/** @internal */\n\n\nfunction expandKey(_ref, options) {\n  var method = _ref.method,\n      prefix = _ref.prefix;\n  return options.key ? options.key : \"\".concat(prefix, \" \").concat(method);\n} // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers(_ref2) {\n  var type = _ref2.meta.type;\n\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey(_ref3) {\n  var method = _ref3.method,\n      prefix = _ref3.prefix;\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, stringKey, args, _ref4) {\n  var _ref5 = _slicedToArray(_ref4, 2),\n      hasher1 = _ref5[0],\n      hasher2 = _ref5[1];\n\n  var _itemFn$meta = itemFn.meta,\n      name = _itemFn$meta.name,\n      type = _itemFn$meta.type; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), \"\".concat((name || 'unknown').toString(), \" is a DoubleMap and requires two arguments\")); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n\n  var _args = _slicedToArray(args, 2),\n      key1 = _args[0],\n      key2 = _args[1];\n\n  var map = type.asDoubleMap;\n  var val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  var val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, stringKey, arg, hasher) {\n  var _itemFn$meta2 = itemFn.meta,\n      name = _itemFn$meta2.name,\n      type = _itemFn$meta2.type;\n  var param = EMPTY_U8A;\n\n  if (type.isMap) {\n    var map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), \"\".concat(name.toString(), \" is a Map and requires one argument\"));\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta(_ref6, storageFn) {\n  var meta = _ref6.meta,\n      method = _ref6.method,\n      prefix = _ref6.prefix,\n      section = _ref6.section;\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = function () {\n    return _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n      storage: {\n        method: method,\n        prefix: prefix,\n        section: section\n      }\n    });\n  };\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, _ref7, _ref8, iterFn) {\n  var _ref7$meta = _ref7.meta,\n      documentation = _ref7$meta.documentation,\n      name = _ref7$meta.name,\n      type = _ref7$meta.type,\n      section = _ref7.section;\n  var method = _ref8.method;\n  var outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation: documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name: name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  var prefixKey = registry.createType('StorageKey', iterFn, {\n    method: method,\n    section: section\n  });\n  return function (arg) {\n    return !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n      method: method,\n      section: section\n    }) : prefixKey;\n  };\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  var type = itemFn.meta.type;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, function (arg) {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? new _codec.Raw(registry, (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a()))) : new _codec.Raw(registry, createPrefixedKey(itemFn));\n  });\n  return storageFn;\n} // attach the full list hashing for double maps\n\n/** @internal */\n\n\nfunction extendDoubleMap(registry, itemFn, storageFn) {\n  return extendPrefixedMap(registry, itemFn, storageFn);\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  var type = itemFn.meta.type;\n  var stringKey = expandKey(itemFn, options);\n\n  var _getHashers = getHashers(itemFn),\n      _getHashers2 = _slicedToArray(_getHashers, 2),\n      hasher = _getHashers2[0],\n      key2Hasher = _getHashers2[1]; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n\n  var _storageFn = function _storageFn(arg) {\n    return type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, stringKey, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, stringKey, arg, options.skipHashing ? NULL_HASHER : hasher);\n  };\n\n  var storageFn = expandWithMeta(itemFn, _storageFn);\n\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  } else if (type.isDoubleMap) {\n    extendDoubleMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = function (arg) {\n    return storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n  };\n\n  return storageFn;\n}","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/createFunction.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","createFunction","_defineProperty2","_codec","_create","_util","_utilCrypto","_getHasher","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","EMPTY_U8A","Uint8Array","NULL_HASHER","expandKey","options","method","prefix","getHashers","type","meta","isDoubleMap","asDoubleMap","hasher","key2Hasher","isMap","asMap","createPrefixedKey","u8aConcat","xxhashAsU8a","createKeyDoubleMap","registry","itemFn","stringKey","args","hasher1","hasher2","name","assert","Array","isArray","isUndefined","isNull","toString","key1","key2","map","val1","createTypeUnsafe","toU8a","val2","Compact","addLengthPrefix","createKey","arg","param","expandWithMeta","storageFn","section","stringLowerFirst","toJSON","storage","extendHeadMeta","iterFn","documentation","outputType","createType","fallback","toHex","modifier","prefixKey","extendPrefixedMap","iterKey","Raw","extendDoubleMap","_storageFn","skipHashing","keyPrefix","compactStripLength"],"mappings":"AAAA;;;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,cAAlB;;AAEA,IAAIC,gBAAgB,GAAGR,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIQ,MAAM,GAAGR,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIS,OAAO,GAAGT,OAAO,CAAC,wBAAD,CAArB;;AAEA,IAAIU,KAAK,GAAGV,OAAO,CAAC,gBAAD,CAAnB;;AAEA,IAAIW,WAAW,GAAGX,OAAO,CAAC,uBAAD,CAAzB;;AAEA,IAAIY,UAAU,GAAGb,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAvC;;AAEA,SAASa,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGf,MAAM,CAACe,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIb,MAAM,CAACgB,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGjB,MAAM,CAACgB,qBAAP,CAA6BH,MAA7B,CAAd;AAAoD,QAAIC,cAAJ,EAAoBG,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,aAAOnB,MAAM,CAACoB,wBAAP,CAAgCP,MAAhC,EAAwCM,GAAxC,EAA6CE,UAApD;AAAiE,KAAjG,CAAV;AAA8GN,IAAAA,IAAI,CAACO,IAAL,CAAUC,KAAV,CAAgBR,IAAhB,EAAsBE,OAAtB;AAAiC;;AAAC,SAAOF,IAAP;AAAc;;AAErV,SAASS,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEd,MAAAA,OAAO,CAACZ,MAAM,CAAC6B,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAE,SAAC,GAAGzB,gBAAgB,CAACF,OAArB,EAA8BqB,MAA9B,EAAsCM,GAAtC,EAA2CF,MAAM,CAACE,GAAD,CAAjD;AAA0D,OAAjH;AAAqH,KAAlI,MAAwI,IAAI/B,MAAM,CAACgC,yBAAX,EAAsC;AAAEhC,MAAAA,MAAM,CAACiC,gBAAP,CAAwBR,MAAxB,EAAgCzB,MAAM,CAACgC,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAEjB,MAAAA,OAAO,CAACZ,MAAM,CAAC6B,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAE/B,QAAAA,MAAM,CAACC,cAAP,CAAsBwB,MAAtB,EAA8BM,GAA9B,EAAmC/B,MAAM,CAACoB,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB;;AAEpiB,IAAMS,SAAS,GAAG,IAAIC,UAAJ,CAAe,EAAf,CAAlB;;AAEA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAjC,KAAK;AAAA,SAAIA,KAAJ;AAAA,CAAzB,C,CAAoC;;AAEpC;;;AAGA,SAASkC,SAAT,OAGGC,OAHH,EAGY;AAAA,MAFVC,MAEU,QAFVA,MAEU;AAAA,MADVC,MACU,QADVA,MACU;AACV,SAAOF,OAAO,CAACP,GAAR,GAAcO,OAAO,CAACP,GAAtB,aAA+BS,MAA/B,cAAyCD,MAAzC,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAASE,UAAT,QAIG;AAAA,MAFCC,IAED,SAHDC,IAGC,CAFCD,IAED;;AACD,MAAIA,IAAI,CAACE,WAAT,EAAsB;AACpB,WAAO,CAAC,CAAC,GAAGjC,UAAU,CAACP,OAAf,EAAwBsC,IAAI,CAACG,WAAL,CAAiBC,MAAzC,CAAD,EAAmD,CAAC,GAAGnC,UAAU,CAACP,OAAf,EAAwBsC,IAAI,CAACG,WAAL,CAAiBE,UAAzC,CAAnD,CAAP;AACD,GAFD,MAEO,IAAIL,IAAI,CAACM,KAAT,EAAgB;AACrB,WAAO,CAAC,CAAC,GAAGrC,UAAU,CAACP,OAAf,EAAwBsC,IAAI,CAACO,KAAL,CAAWH,MAAnC,CAAD,CAAP;AACD,GALA,CAKC;;;AAGF,SAAO,CAAC,CAAC,GAAGnC,UAAU,CAACP,OAAf,GAAD,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAAS8C,iBAAT,QAGG;AAAA,MAFDX,MAEC,SAFDA,MAEC;AAAA,MADDC,MACC,SADDA,MACC;AACD,SAAO,CAAC,GAAG/B,KAAK,CAAC0C,SAAV,EAAqB,CAAC,GAAGzC,WAAW,CAAC0C,WAAhB,EAA6BZ,MAA7B,EAAqC,GAArC,CAArB,EAAgE,CAAC,GAAG9B,WAAW,CAAC0C,WAAhB,EAA6Bb,MAA7B,EAAqC,GAArC,CAAhE,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAASc,kBAAT,CAA4BC,QAA5B,EAAsCC,MAAtC,EAA8CC,SAA9C,EAAyDC,IAAzD,SAAmF;AAAA;AAAA,MAAnBC,OAAmB;AAAA,MAAVC,OAAU;;AAAA,qBAM7EJ,MAN6E,CAE/EZ,IAF+E;AAAA,MAG7EiB,IAH6E,gBAG7EA,IAH6E;AAAA,MAI7ElB,IAJ6E,gBAI7EA,IAJ6E,EAMrE;;AAEZ,GAAC,GAAGjC,KAAK,CAACoD,MAAV,EAAkBC,KAAK,CAACC,OAAN,CAAcN,IAAd,KAAuB,CAAC,CAAC,GAAGhD,KAAK,CAACuD,WAAV,EAAuBP,IAAI,CAAC,CAAD,CAA3B,CAAxB,IAA2D,CAAC,CAAC,GAAGhD,KAAK,CAACwD,MAAV,EAAkBR,IAAI,CAAC,CAAD,CAAtB,CAA5D,IAA0F,CAAC,CAAC,GAAGhD,KAAK,CAACuD,WAAV,EAAuBP,IAAI,CAAC,CAAD,CAA3B,CAA3F,IAA8H,CAAC,CAAC,GAAGhD,KAAK,CAACwD,MAAV,EAAkBR,IAAI,CAAC,CAAD,CAAtB,CAAjJ,YAAgL,CAACG,IAAI,IAAI,SAAT,EAAoBM,QAApB,EAAhL,iDARiF,CAQ4K;;AAE7P,GAAC,GAAGzD,KAAK,CAACoD,MAAV,EAAkB,CAAC,CAAC,GAAGpD,KAAK,CAACuD,WAAV,EAAuBL,OAAvB,CAAnB,EAAoD,sDAApD;;AAViF,6BAW5DF,IAX4D;AAAA,MAW1EU,IAX0E;AAAA,MAWpEC,IAXoE;;AAYjF,MAAMC,GAAG,GAAG3B,IAAI,CAACG,WAAjB;AACA,MAAMyB,IAAI,GAAG,CAAC,GAAG9D,OAAO,CAAC+D,gBAAZ,EAA8BjB,QAA9B,EAAwCe,GAAG,CAACF,IAAJ,CAASD,QAAT,EAAxC,EAA6D,CAACC,IAAD,CAA7D,EAAqEK,KAArE,EAAb;AACA,MAAMC,IAAI,GAAG,CAAC,GAAGjE,OAAO,CAAC+D,gBAAZ,EAA8BjB,QAA9B,EAAwCe,GAAG,CAACD,IAAJ,CAASF,QAAT,EAAxC,EAA6D,CAACE,IAAD,CAA7D,EAAqEI,KAArE,EAAb,CAdiF,CAcU;;AAE3F,SAAOjE,MAAM,CAACmE,OAAP,CAAeC,eAAf,CAA+B,CAAC,GAAGlE,KAAK,CAAC0C,SAAV,EAAqBD,iBAAiB,CAACK,MAAD,CAAtC,EAAgDG,OAAO,CAACY,IAAD,CAAvD,EAA+DX,OAAO,CAACc,IAAD,CAAtE,CAA/B,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAASG,SAAT,CAAmBtB,QAAnB,EAA6BC,MAA7B,EAAqCC,SAArC,EAAgDqB,GAAhD,EAAqD/B,MAArD,EAA6D;AAAA,sBAMvDS,MANuD,CAEzDZ,IAFyD;AAAA,MAGvDiB,IAHuD,iBAGvDA,IAHuD;AAAA,MAIvDlB,IAJuD,iBAIvDA,IAJuD;AAO3D,MAAIoC,KAAK,GAAG5C,SAAZ;;AAEA,MAAIQ,IAAI,CAACM,KAAT,EAAgB;AACd,QAAMqB,GAAG,GAAG3B,IAAI,CAACO,KAAjB;AACA,KAAC,GAAGxC,KAAK,CAACoD,MAAV,EAAkB,CAAC,CAAC,GAAGpD,KAAK,CAACuD,WAAV,EAAuBa,GAAvB,CAAD,IAAgC,CAAC,CAAC,GAAGpE,KAAK,CAACwD,MAAV,EAAkBY,GAAlB,CAAnD,YAA8EjB,IAAI,CAACM,QAAL,EAA9E;AACAY,IAAAA,KAAK,GAAG,CAAC,GAAGtE,OAAO,CAAC+D,gBAAZ,EAA8BjB,QAA9B,EAAwCe,GAAG,CAACtC,GAAJ,CAAQmC,QAAR,EAAxC,EAA4D,CAACW,GAAD,CAA5D,EAAmEL,KAAnE,EAAR;AACD,GAb0D,CAazD;;;AAGF,SAAOjE,MAAM,CAACmE,OAAP,CAAeC,eAAf,CAA+B,CAAC,GAAGlE,KAAK,CAAC0C,SAAV,EAAqBD,iBAAiB,CAACK,MAAD,CAAtC,EAAgDuB,KAAK,CAAClD,MAAN,GAAekB,MAAM,CAACgC,KAAD,CAArB,GAA+B5C,SAA/E,CAA/B,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAAS6C,cAAT,QAKGC,SALH,EAKc;AAAA,MAJZrC,IAIY,SAJZA,IAIY;AAAA,MAHZJ,MAGY,SAHZA,MAGY;AAAA,MAFZC,MAEY,SAFZA,MAEY;AAAA,MADZyC,OACY,SADZA,OACY;AACZD,EAAAA,SAAS,CAACrC,IAAV,GAAiBA,IAAjB;AACAqC,EAAAA,SAAS,CAACzC,MAAV,GAAmB,CAAC,GAAG9B,KAAK,CAACyE,gBAAV,EAA4B3C,MAA5B,CAAnB;AACAyC,EAAAA,SAAS,CAACxC,MAAV,GAAmBA,MAAnB;AACAwC,EAAAA,SAAS,CAACC,OAAV,GAAoBA,OAApB,CAJY,CAIiB;AAC7B;;AAEAD,EAAAA,SAAS,CAACG,MAAV,GAAmB;AAAA,WAAM3D,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKmB,IAAI,CAACwC,MAAL,EAAL,CAAd,EAAmC,EAAnC,EAAuC;AAC3EC,MAAAA,OAAO,EAAE;AACP7C,QAAAA,MAAM,EAANA,MADO;AAEPC,QAAAA,MAAM,EAANA,MAFO;AAGPyC,QAAAA,OAAO,EAAPA;AAHO;AADkE,KAAvC,CAAnB;AAAA,GAAnB;;AAQA,SAAOD,SAAP;AACD;AACD;;;AAGA,SAASK,cAAT,CAAwB/B,QAAxB,gBASGgC,MATH,EASW;AAAA,yBART3C,IAQS;AAAA,MAPP4C,aAOO,cAPPA,aAOO;AAAA,MANP3B,IAMO,cANPA,IAMO;AAAA,MALPlB,IAKO,cALPA,IAKO;AAAA,MAHTuC,OAGS,SAHTA,OAGS;AAAA,MADT1C,MACS,SADTA,MACS;AACT,MAAMiD,UAAU,GAAG9C,IAAI,CAACM,KAAL,GAAaN,IAAI,CAACO,KAAL,CAAWlB,GAAX,CAAemC,QAAf,EAAb,GAAyCxB,IAAI,CAACG,WAAL,CAAiBsB,IAAjB,CAAsBD,QAAtB,EAA5D,CADS,CACqF;AAC9F;;AAEAoB,EAAAA,MAAM,CAAC3C,IAAP,GAAcW,QAAQ,CAACmC,UAAT,CAAoB,4BAApB,EAAkD;AAC9DF,IAAAA,aAAa,EAAbA,aAD8D;AAE9DG,IAAAA,QAAQ,EAAEpC,QAAQ,CAACmC,UAAT,CAAoB,OAApB,EAA6B,CAAC,GAAGjF,OAAO,CAAC+D,gBAAZ,EAA8BjB,QAA9B,EAAwCkC,UAAxC,EAAoDG,KAApD,EAA7B,CAFoD;AAG9DC,IAAAA,QAAQ,EAAEtC,QAAQ,CAACmC,UAAT,CAAoB,4BAApB,EAAkD,CAAlD,CAHoD;AAI9D;AACA7B,IAAAA,IAAI,EAAJA,IAL8D;AAM9DlB,IAAAA,IAAI,EAAEY,QAAQ,CAACmC,UAAT,CAAoB,wBAApB,EAA8CnC,QAAQ,CAACmC,UAAT,CAAoB,MAApB,EAA4B/C,IAAI,CAACM,KAAL,GAAaN,IAAI,CAACO,KAAL,CAAWlB,GAAxB,GAA8BW,IAAI,CAACG,WAAL,CAAiBsB,IAA3E,CAA9C,EAAgI,CAAhI;AANwD,GAAlD,CAAd;AAQA,MAAM0B,SAAS,GAAGvC,QAAQ,CAACmC,UAAT,CAAoB,YAApB,EAAkCH,MAAlC,EAA0C;AAC1D/C,IAAAA,MAAM,EAANA,MAD0D;AAE1D0C,IAAAA,OAAO,EAAPA;AAF0D,GAA1C,CAAlB;AAIA,SAAO,UAAAJ,GAAG;AAAA,WAAI,CAAC,CAAC,GAAGpE,KAAK,CAACuD,WAAV,EAAuBa,GAAvB,CAAD,IAAgC,CAAC,CAAC,GAAGpE,KAAK,CAACwD,MAAV,EAAkBY,GAAlB,CAAjC,GAA0DvB,QAAQ,CAACmC,UAAT,CAAoB,YAApB,EAAkCH,MAAM,CAACT,GAAD,CAAxC,EAA+C;AACrHtC,MAAAA,MAAM,EAANA,MADqH;AAErH0C,MAAAA,OAAO,EAAPA;AAFqH,KAA/C,CAA1D,GAGTY,SAHK;AAAA,GAAV;AAID,C,CAAC;;AAEF;;;AAGA,SAASC,iBAAT,CAA2BxC,QAA3B,EAAqCC,MAArC,EAA6CyB,SAA7C,EAAwD;AAAA,MAGlDtC,IAHkD,GAKlDa,MALkD,CAEpDZ,IAFoD,CAGlDD,IAHkD;AAMtDsC,EAAAA,SAAS,CAACe,OAAV,GAAoBV,cAAc,CAAC/B,QAAD,EAAWC,MAAX,EAAmByB,SAAnB,EAA8B,UAAAH,GAAG,EAAI;AACrE,KAAC,GAAGpE,KAAK,CAACoD,MAAV,EAAkBnB,IAAI,CAACE,WAAL,IAAoB,CAAC,GAAGnC,KAAK,CAACuD,WAAV,EAAuBa,GAAvB,CAAtC,EAAmE,oEAAnE;AACA,WAAOnC,IAAI,CAACE,WAAL,IAAoB,CAAC,CAAC,GAAGnC,KAAK,CAACuD,WAAV,EAAuBa,GAAvB,CAArB,IAAoD,CAAC,CAAC,GAAGpE,KAAK,CAACwD,MAAV,EAAkBY,GAAlB,CAArD,GAA8E,IAAItE,MAAM,CAACyF,GAAX,CAAe1C,QAAf,EAAyB,CAAC,GAAG7C,KAAK,CAAC0C,SAAV,EAAqBD,iBAAiB,CAACK,MAAD,CAAtC,EAAgD,CAAC,GAAG5C,UAAU,CAACP,OAAf,EAAwBsC,IAAI,CAACG,WAAL,CAAiBC,MAAzC,EAAiDQ,QAAQ,CAACmC,UAAT,CAAoB/C,IAAI,CAACG,WAAL,CAAiBsB,IAAjB,CAAsBD,QAAtB,EAApB,EAAsDW,GAAtD,EAA2DL,KAA3D,EAAjD,CAAhD,CAAzB,CAA9E,GAAgR,IAAIjE,MAAM,CAACyF,GAAX,CAAe1C,QAAf,EAAyBJ,iBAAiB,CAACK,MAAD,CAA1C,CAAvR;AACD,GAHiC,CAAlC;AAIA,SAAOyB,SAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAASiB,eAAT,CAAyB3C,QAAzB,EAAmCC,MAAnC,EAA2CyB,SAA3C,EAAsD;AACpD,SAAOc,iBAAiB,CAACxC,QAAD,EAAWC,MAAX,EAAmByB,SAAnB,CAAxB;AACD;AACD;;;AAGA,SAAS3E,cAAT,CAAwBiD,QAAxB,EAAkCC,MAAlC,EAA0CjB,OAA1C,EAAmD;AAAA,MAG7CI,IAH6C,GAK7Ca,MAL6C,CAE/CZ,IAF+C,CAG7CD,IAH6C;AAMjD,MAAMc,SAAS,GAAGnB,SAAS,CAACkB,MAAD,EAASjB,OAAT,CAA3B;;AANiD,oBAOpBG,UAAU,CAACc,MAAD,CAPU;AAAA;AAAA,MAO1CT,MAP0C;AAAA,MAOlCC,UAPkC,oBAOA;AACjD;AACA;AACA;;;AAEA,MAAMmD,UAAU,GAAG,SAAbA,UAAa,CAAArB,GAAG;AAAA,WAAInC,IAAI,CAACE,WAAL,GAAmBS,kBAAkB,CAACC,QAAD,EAAWC,MAAX,EAAmBC,SAAnB,EAA8BqB,GAA9B,EAAmC,CAAC/B,MAAD,EAASC,UAAT,CAAnC,CAArC,GAAgG6B,SAAS,CAACtB,QAAD,EAAWC,MAAX,EAAmBC,SAAnB,EAA8BqB,GAA9B,EAAmCvC,OAAO,CAAC6D,WAAR,GAAsB/D,WAAtB,GAAoCU,MAAvE,CAA7G;AAAA,GAAtB;;AAEA,MAAMkC,SAAS,GAAGD,cAAc,CAACxB,MAAD,EAAS2C,UAAT,CAAhC;;AAEA,MAAIxD,IAAI,CAACM,KAAT,EAAgB;AACd8C,IAAAA,iBAAiB,CAACxC,QAAD,EAAWC,MAAX,EAAmByB,SAAnB,CAAjB;AACD,GAFD,MAEO,IAAItC,IAAI,CAACE,WAAT,EAAsB;AAC3BqD,IAAAA,eAAe,CAAC3C,QAAD,EAAWC,MAAX,EAAmByB,SAAnB,CAAf;AACD;;AAEDA,EAAAA,SAAS,CAACoB,SAAV,GAAsB,UAAAvB,GAAG;AAAA,WAAIG,SAAS,CAACe,OAAV,IAAqBf,SAAS,CAACe,OAAV,CAAkBlB,GAAlB,CAArB,IAA+C,CAAC,GAAGpE,KAAK,CAAC4F,kBAAV,EAA8BrB,SAAS,EAAvC,EAA2C,CAA3C,CAAnD;AAAA,GAAzB;;AAEA,SAAOA,SAAP;AACD","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // with the prefix, method & options, create both the string & raw keys\n\n/** @internal */\n\n\nfunction expandKey({\n  method,\n  prefix\n}, options) {\n  return options.key ? options.key : `${prefix} ${method}`;\n} // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, stringKey, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, stringKey, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, storageFn) {\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? new _codec.Raw(registry, (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a()))) : new _codec.Raw(registry, createPrefixedKey(itemFn));\n  });\n  return storageFn;\n} // attach the full list hashing for double maps\n\n/** @internal */\n\n\nfunction extendDoubleMap(registry, itemFn, storageFn) {\n  return extendPrefixedMap(registry, itemFn, storageFn);\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const stringKey = expandKey(itemFn, options);\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const _storageFn = arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, stringKey, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, stringKey, arg, options.skipHashing ? NULL_HASHER : hasher);\n\n  const storageFn = expandWithMeta(itemFn, _storageFn);\n\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  } else if (type.isDoubleMap) {\n    extendDoubleMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"script"}