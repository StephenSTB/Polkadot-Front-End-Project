{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _AbstractArray = _interopRequireDefault(require(\"./AbstractArray\"));\n\nvar _utils = require(\"./utils\");\n\nvar _Vec = _interopRequireDefault(require(\"./Vec\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @name VecFixed\n * @description\n * This manages codec arrays of a fixed length\n */\n\n\nvar VecFixed = /*#__PURE__*/function (_AbstractArray$defaul) {\n  _inherits(VecFixed, _AbstractArray$defaul);\n\n  var _super = _createSuper(VecFixed);\n\n  function VecFixed(registry, Type, length) {\n    var _this;\n\n    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    _classCallCheck(this, VecFixed);\n\n    var Clazz = (0, _utils.typeToConstructor)(registry, Type);\n    _this = _super.call.apply(_super, [this, registry].concat(_toConsumableArray(VecFixed.decodeVecFixed(registry, Clazz, length, value))));\n    _this._Type = void 0;\n    _this._Type = Clazz;\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(VecFixed, [{\n    key: \"toU8a\",\n    value: function toU8a() {\n      // we override, we don't add the length prefix for ourselves, and at the same time we\n      // ignore isBare on entries, since they should be properly encoded at all times\n      var encoded = this.map(function (entry) {\n        return entry.toU8a();\n      });\n      return encoded.length ? (0, _util.u8aConcat).apply(void 0, _toConsumableArray(encoded)) : new Uint8Array([]);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return \"[\".concat(this.Type, \";\").concat(this.length, \"]\");\n    }\n  }, {\n    key: \"Type\",\n\n    /**\n     * @description The type for the items\n     */\n    get: function get() {\n      return new this._Type(this.registry).toRawType();\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n\n  }, {\n    key: \"encodedLength\",\n    get: function get() {\n      return this.toU8a().length;\n    }\n  }], [{\n    key: \"decodeVecFixed\",\n    value: function decodeVecFixed(registry, Type, allocLength, value) {\n      var values = _Vec.default.decodeVec(registry, Type, (0, _util.isU8a)(value) ? (0, _util.u8aConcat)((0, _util.compactToU8a)(allocLength), value) : value);\n\n      while (values.length < allocLength) {\n        values.push(new Type(registry));\n      }\n\n      (0, _util.assert)(values.length === allocLength, \"Expected a length of exactly \".concat(allocLength, \" entries\"));\n      return values;\n    }\n  }, {\n    key: \"with\",\n    value: function _with(Type, length) {\n      return /*#__PURE__*/function (_VecFixed) {\n        _inherits(_class, _VecFixed);\n\n        var _super2 = _createSuper(_class);\n\n        function _class(registry, value) {\n          _classCallCheck(this, _class);\n\n          return _super2.call(this, registry, Type, length, value);\n        }\n\n        return _class;\n      }(VecFixed);\n    }\n  }]);\n\n  return VecFixed;\n}(_AbstractArray.default);\n\nexports.default = VecFixed;","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/codec/VecFixed.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_util","_AbstractArray","_utils","_Vec","VecFixed","registry","Type","length","Clazz","typeToConstructor","decodeVecFixed","_Type","encoded","map","entry","toU8a","u8aConcat","Uint8Array","toRawType","allocLength","values","decodeVec","isU8a","compactToU8a","push","assert"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _AbstractArray = _interopRequireDefault(require(\"./AbstractArray\"));\n\nvar _utils = require(\"./utils\");\n\nvar _Vec = _interopRequireDefault(require(\"./Vec\"));\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @name VecFixed\n * @description\n * This manages codec arrays of a fixed length\n */\nclass VecFixed extends _AbstractArray.default {\n  constructor(registry, Type, length, value = []) {\n    const Clazz = (0, _utils.typeToConstructor)(registry, Type);\n    super(registry, ...VecFixed.decodeVecFixed(registry, Clazz, length, value));\n    this._Type = void 0;\n    this._Type = Clazz;\n  }\n  /** @internal */\n\n\n  static decodeVecFixed(registry, Type, allocLength, value) {\n    const values = _Vec.default.decodeVec(registry, Type, (0, _util.isU8a)(value) ? (0, _util.u8aConcat)((0, _util.compactToU8a)(allocLength), value) : value);\n\n    while (values.length < allocLength) {\n      values.push(new Type(registry));\n    }\n\n    (0, _util.assert)(values.length === allocLength, `Expected a length of exactly ${allocLength} entries`);\n    return values;\n  }\n\n  static with(Type, length) {\n    return class extends VecFixed {\n      constructor(registry, value) {\n        super(registry, Type, length, value);\n      }\n\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n\n\n  get Type() {\n    return new this._Type(this.registry).toRawType();\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n\n  toU8a() {\n    // we override, we don't add the length prefix for ourselves, and at the same time we\n    // ignore isBare on entries, since they should be properly encoded at all times\n    const encoded = this.map(entry => entry.toU8a());\n    return encoded.length ? (0, _util.u8aConcat)(...encoded) : new Uint8Array([]);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `[${this.Type};${this.length}]`;\n  }\n\n}\n\nexports.default = VecFixed;"]},"metadata":{},"sourceType":"script"}