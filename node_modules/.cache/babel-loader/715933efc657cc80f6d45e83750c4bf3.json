{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _Extrinsic = require(\"@polkadot/types/extrinsic/Extrinsic\");\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Decorate = _interopRequireDefault(require(\"./Decorate\")); // Copyright 2017-2020 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nvar KEEPALIVE_INTERVAL = 15000;\nvar DEFAULT_BLOCKNUMBER = {\n  unwrap: function unwrap() {\n    return _util.BN_ZERO;\n  }\n};\nvar l = (0, _util.logger)('api/init');\n\nvar _healthTimer = (0, _classPrivateFieldLooseKey2.default)(\"healthTimer\");\n\nvar _registries = (0, _classPrivateFieldLooseKey2.default)(\"registries\");\n\nvar _updateSub = (0, _classPrivateFieldLooseKey2.default)(\"updateSub\");\n\nvar _onProviderConnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderConnect\");\n\nvar _onProviderDisconnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderDisconnect\");\n\nvar _onProviderError = (0, _classPrivateFieldLooseKey2.default)(\"onProviderError\");\n\nvar Init = /*#__PURE__*/function (_Decorate$default) {\n  _inherits(Init, _Decorate$default);\n\n  var _super = _createSuper(Init);\n\n  function Init(options, type, decorateMethod) {\n    var _this;\n\n    _classCallCheck(this, Init);\n\n    _this = _super.call(this, options, type, decorateMethod);\n    Object.defineProperty(_assertThisInitialized(_this), _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderConnect, {\n      writable: true,\n      value: function () {\n        var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var _yield$Promise$all, _yield$Promise$all2, hasMeta, cryptoReady, error;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _this.emit('connected');\n\n                  _this._isConnected.next(true);\n\n                  _context.prev = 2;\n                  _context.next = 5;\n                  return Promise.all([_this._loadMeta(), _this._options.initWasm === false ? Promise.resolve(true) : (0, _utilCrypto.cryptoWaitReady)()]);\n\n                case 5:\n                  _yield$Promise$all = _context.sent;\n                  _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                  hasMeta = _yield$Promise$all2[0];\n                  cryptoReady = _yield$Promise$all2[1];\n\n                  if (hasMeta && !_this._isReady && cryptoReady) {\n                    _this._isReady = true;\n\n                    _this.emit('ready', _assertThisInitialized(_this));\n                  }\n\n                  (0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _healthTimer)[_healthTimer] = setInterval(function () {\n                    _this._rpcCore.system.health().toPromise().catch(function () {// ignore\n                    });\n                  }, KEEPALIVE_INTERVAL);\n                  _context.next = 18;\n                  break;\n\n                case 13:\n                  _context.prev = 13;\n                  _context.t0 = _context[\"catch\"](2);\n                  error = new Error(\"FATAL: Unable to initialize the API: \".concat(_context.t0.message));\n                  l.error(error);\n\n                  _this.emit('error', error);\n\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[2, 13]]);\n        }));\n\n        function value() {\n          return _value.apply(this, arguments);\n        }\n\n        return value;\n      }()\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderDisconnect, {\n      writable: true,\n      value: function value() {\n        _this.emit('disconnected');\n\n        _this._isConnected.next(false);\n\n        if ((0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _healthTimer)[_healthTimer]) {\n          clearInterval((0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _healthTimer)[_healthTimer]);\n          (0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderError, {\n      writable: true,\n      value: function value(error) {\n        _this.emit('error', error);\n      }\n    });\n\n    if (!_this.hasSubscriptions) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // all injected types added to the registry for overrides\n\n\n    _this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n\n    if (!options.source) {\n      _this.registerTypes(options.types);\n    } else {\n      (0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _registries)[_registries] = (0, _classPrivateFieldLooseBase2.default)(options.source, _registries)[_registries];\n    }\n\n    _this._rpc = _this._decorateRpc(_this._rpcCore, _this._decorateMethod);\n    _this._rx.rpc = _this._decorateRpc(_this._rpcCore, _this._rxDecorateMethod);\n    _this._queryMulti = _this._decorateMulti(_this._decorateMethod);\n    _this._rx.queryMulti = _this._decorateMulti(_this._rxDecorateMethod);\n    _this._rx.signer = options.signer;\n\n    _this._rpcCore.setRegistrySwap(function (hash) {\n      return _this.getBlockRegistry(hash);\n    });\n\n    _this._rpcCore.provider.on('disconnected', (0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _onProviderDisconnect)[_onProviderDisconnect]);\n\n    _this._rpcCore.provider.on('error', (0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _onProviderError)[_onProviderError]);\n\n    _this._rpcCore.provider.on('connected', (0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _onProviderConnect)[_onProviderConnect]); // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (_this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      (0, _classPrivateFieldLooseBase2.default)(_assertThisInitialized(_this), _onProviderConnect)[_onProviderConnect]();\n    }\n\n    return _this;\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _createClass(Init, [{\n    key: \"_initRegistry\",\n    value: function _initRegistry(registry, chain, version, chainProps) {\n      registry.setChainProperties(chainProps || this.registry.getChainProperties());\n      registry.setKnownTypes(this._options);\n      registry.register((0, _typesKnown.getSpecTypes)(registry, chain, version.specName, version.specVersion)); // for bundled types, pull through the aliasses defined\n\n      if (registry.knownTypes.typesBundle) {\n        registry.knownTypes.typesAlias = (0, _typesKnown.getSpecAlias)(registry, chain, version.specName);\n      }\n\n      return registry;\n    }\n    /**\n     * @description Sets up a registry based on the block hash defined\n     */\n\n  }, {\n    key: \"getBlockRegistry\",\n    value: function () {\n      var _getBlockRegistry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blockHash) {\n        var lastBlockHash, existingViaHash, header, _ref, _ref2, firstVersion, lastVersion, version, existingViaVersion, registry, metadata, result;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // shortcut in the case where we have an immediate-same request\n                lastBlockHash = (0, _util.u8aToU8a)(blockHash);\n                existingViaHash = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(function (r) {\n                  return r.lastBlockHash && (0, _util.u8aEq)(lastBlockHash, r.lastBlockHash);\n                });\n\n                if (!existingViaHash) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", existingViaHash);\n\n              case 4:\n                // ensure we have everything required\n                (0, _util.assert)(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n                // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n                if (!this._genesisHash.eq(blockHash)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                _context2.t0 = {\n                  number: DEFAULT_BLOCKNUMBER,\n                  parentHash: this._genesisHash\n                };\n                _context2.next = 12;\n                break;\n\n              case 9:\n                _context2.next = 11;\n                return this._rpcCore.chain.getHeader(blockHash).toPromise();\n\n              case 11:\n                _context2.t0 = _context2.sent;\n\n              case 12:\n                header = _context2.t0;\n                (0, _util.assert)((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n                _ref = (0, _typesKnown.getUpgradeVersion)(this._genesisHash, header.number.unwrap()), _ref2 = _slicedToArray(_ref, 2), firstVersion = _ref2[0], lastVersion = _ref2[1];\n\n                if (!(firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)))) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                _context2.t1 = {\n                  specName: this._runtimeVersion.specName,\n                  specVersion: firstVersion.specVersion\n                };\n                _context2.next = 22;\n                break;\n\n              case 19:\n                _context2.next = 21;\n                return this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise();\n\n              case 21:\n                _context2.t1 = _context2.sent;\n\n              case 22:\n                version = _context2.t1;\n                // check for pre-existing registries\n                existingViaVersion = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(function (r) {\n                  return r.specVersion.eq(version.specVersion);\n                });\n\n                if (!existingViaVersion) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                existingViaVersion.lastBlockHash = lastBlockHash;\n                return _context2.abrupt(\"return\", existingViaVersion);\n\n              case 27:\n                // nothing has been found, construct new\n                registry = this._initRegistry(new _types.TypeRegistry(), this._runtimeChain, version);\n                _context2.next = 30;\n                return this._rpcCore.state.getMetadata(header.parentHash).toPromise();\n\n              case 30:\n                metadata = _context2.sent;\n                result = {\n                  isDefault: false,\n                  lastBlockHash: lastBlockHash,\n                  metadata: metadata,\n                  metadataConsts: null,\n                  registry: registry,\n                  specVersion: version.specVersion\n                };\n                registry.setMetadata(metadata);\n\n                (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push(result);\n\n                return _context2.abrupt(\"return\", result);\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getBlockRegistry(_x) {\n        return _getBlockRegistry.apply(this, arguments);\n      }\n\n      return getBlockRegistry;\n    }()\n  }, {\n    key: \"_loadMeta\",\n    value: function () {\n      var _loadMeta2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this$_options$source, genesisHash, _this$_options$metada, metadata;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._rpcCore.chain.getBlockHash(0).toPromise();\n\n              case 2:\n                genesisHash = _context3.sent;\n\n                if (!(this._isReady && !this._options.source && genesisHash.eq(this._genesisHash))) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", true);\n\n              case 5:\n                if (this._genesisHash) {\n                  l.warn('Connection to new genesis detected, re-initializing');\n                }\n\n                this._genesisHash = genesisHash;\n\n                if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {\n                  (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub].unsubscribe();\n                }\n\n                _this$_options$metada = this._options.metadata, metadata = _this$_options$metada === void 0 ? {} : _this$_options$metada; // only load from on-chain if we are not a clone (default path), alternatively\n                // just use the values from the source instance provided\n\n                if (!((_this$_options$source = this._options.source) === null || _this$_options$source === void 0 ? void 0 : _this$_options$source._isReady)) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                _context3.next = 12;\n                return this._metaFromSource(this._options.source);\n\n              case 12:\n                _context3.t0 = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 15:\n                _context3.next = 17;\n                return this._metaFromChain(metadata);\n\n              case 17:\n                _context3.t0 = _context3.sent;\n\n              case 18:\n                this._runtimeMetadata = _context3.t0;\n                return _context3.abrupt(\"return\", this._initFromMeta(this._runtimeMetadata));\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _loadMeta() {\n        return _loadMeta2.apply(this, arguments);\n      }\n\n      return _loadMeta;\n    }() // eslint-disable-next-line @typescript-eslint/require-await\n\n  }, {\n    key: \"_metaFromSource\",\n    value: function () {\n      var _metaFromSource2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(source) {\n        var methods;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._extrinsicType = source.extrinsicVersion;\n                this._runtimeChain = source.runtimeChain;\n                this._runtimeVersion = source.runtimeVersion;\n                this._genesisHash = source.genesisHash;\n                methods = []; // manually build a list of all available methods in this RPC, we are\n                // going to filter on it to align the cloned RPC without making a call\n\n                Object.keys(source.rpc).forEach(function (section) {\n                  Object.keys(source.rpc[section]).forEach(function (method) {\n                    methods.push(\"\".concat(section, \"_\").concat(method));\n                  });\n                });\n\n                this._filterRpcMethods(methods);\n\n                return _context4.abrupt(\"return\", source.runtimeMetadata);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _metaFromSource(_x2) {\n        return _metaFromSource2.apply(this, arguments);\n      }\n\n      return _metaFromSource;\n    }() // subscribe to metadata updates, inject the types on changes\n\n  }, {\n    key: \"_subscribeUpdates\",\n    value: function _subscribeUpdates() {\n      var _this2 = this;\n\n      if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n        return;\n      }\n\n      (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _operators.switchMap)(function (version) {\n        var _this$_runtimeVersion;\n\n        return (// only retrieve the metadata when the on-chain version has been changed\n          ((_this$_runtimeVersion = _this2._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specVersion.eq(version.specVersion)) ? (0, _rxjs.of)(false) : _this2._rpcCore.state.getMetadata().pipe((0, _operators.map)(function (metadata) {\n            l.log(\"Runtime version updated to spec=\".concat(version.specVersion.toString(), \", tx=\").concat(version.transactionVersion.toString()));\n            _this2._runtimeMetadata = metadata;\n            _this2._runtimeVersion = version;\n            _this2._rx.runtimeVersion = version; // update the default registry version\n\n            var thisRegistry = (0, _classPrivateFieldLooseBase2.default)(_this2, _registries)[_registries].find(function (_ref3) {\n              var isDefault = _ref3.isDefault;\n              return isDefault;\n            });\n\n            (0, _util.assert)(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n            thisRegistry.metadata = metadata;\n            thisRegistry.metadataConsts = null;\n            thisRegistry.registry.setMetadata(metadata);\n            thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n            _this2._initRegistry(thisRegistry.registry.init(), _this2._runtimeChain, version);\n\n            _this2.injectMetadata(metadata, false, thisRegistry.registry);\n\n            return true;\n          }))\n        );\n      })).subscribe();\n    }\n  }, {\n    key: \"_metaFromChain\",\n    value: function () {\n      var _metaFromChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(optMetadata) {\n        var _this$_genesisHash, _yield$Promise$all3, _yield$Promise$all4, runtimeVersion, chain, chainProps, metadataKey, metadata;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return Promise.all([this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise()]);\n\n              case 2:\n                _yield$Promise$all3 = _context5.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 3);\n                runtimeVersion = _yield$Promise$all4[0];\n                chain = _yield$Promise$all4[1];\n                chainProps = _yield$Promise$all4[2];\n                // set our chain version & genesisHash as returned\n                this._runtimeChain = chain;\n                this._runtimeVersion = runtimeVersion;\n                this._rx.runtimeVersion = runtimeVersion; // initializes the registry\n\n                this._initRegistry(this.registry, chain, runtimeVersion, chainProps);\n\n                this._subscribeUpdates(); // filter the RPC methods (this does an rpc-methods call)\n\n\n                _context5.next = 14;\n                return this._filterRpc();\n\n              case 14:\n                // retrieve metadata, either from chain  or as pass-in via options\n                metadataKey = \"\".concat(((_this$_genesisHash = this._genesisHash) === null || _this$_genesisHash === void 0 ? void 0 : _this$_genesisHash.toHex()) || '0x', \"-\").concat(runtimeVersion.specVersion.toString());\n\n                if (!(metadataKey in optMetadata)) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                _context5.t0 = new _types.Metadata(this.registry, optMetadata[metadataKey]);\n                _context5.next = 22;\n                break;\n\n              case 19:\n                _context5.next = 21;\n                return this._rpcCore.state.getMetadata().toPromise();\n\n              case 21:\n                _context5.t0 = _context5.sent;\n\n              case 22:\n                metadata = _context5.t0;\n                this.registry.setMetadata(metadata); // setup the initial registry, when we have none\n\n                if (!(0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].length) {\n                  (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push({\n                    isDefault: true,\n                    lastBlockHash: null,\n                    metadata: metadata,\n                    metadataConsts: null,\n                    registry: this.registry,\n                    specVersion: runtimeVersion.specVersion\n                  });\n                } // get unique types & validate\n\n\n                metadata.getUniqTypes(false);\n                return _context5.abrupt(\"return\", metadata);\n\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _metaFromChain(_x3) {\n        return _metaFromChain2.apply(this, arguments);\n      }\n\n      return _metaFromChain;\n    }()\n  }, {\n    key: \"_initFromMeta\",\n    value: function () {\n      var _initFromMeta2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(metadata) {\n        var metaExtrinsic, _yield$this$_rpcCore$, _yield$this$_rpcCore$2, firstTx;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)\n\n                if (!metaExtrinsic.version.gt(_util.BN_ZERO)) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                this._extrinsicType = metaExtrinsic.version.toNumber();\n                _context6.next = 12;\n                break;\n\n              case 5:\n                if (this._options.source) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                _context6.next = 8;\n                return this._rpcCore.chain.getBlock().toPromise();\n\n              case 8:\n                _yield$this$_rpcCore$ = _context6.sent;\n                _yield$this$_rpcCore$2 = _slicedToArray(_yield$this$_rpcCore$.block.extrinsics, 1);\n                firstTx = _yield$this$_rpcCore$2[0];\n                // If we haven't sync-ed to 1 yes, this won't have any values\n                this._extrinsicType = firstTx ? firstTx.type : _Extrinsic.LATEST_EXTRINSIC_VERSION;\n\n              case 12:\n                this._rx.extrinsicType = this._extrinsicType;\n                this._rx.genesisHash = this._genesisHash;\n                this._rx.runtimeVersion = this._runtimeVersion;\n                this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx\n\n                this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n                this._derive = this._decorateDerive(this._decorateMethod);\n                return _context6.abrupt(\"return\", true);\n\n              case 19:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _initFromMeta(_x4) {\n        return _initFromMeta2.apply(this, arguments);\n      }\n\n      return _initFromMeta;\n    }()\n  }]);\n\n  return Init;\n}(_Decorate.default);\n\nexports.default = Init;","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api/base/Init.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_classPrivateFieldLooseBase2","_classPrivateFieldLooseKey2","_rxjs","_operators","_types","_Extrinsic","_typesKnown","_util","_utilCrypto","_Decorate","KEEPALIVE_INTERVAL","DEFAULT_BLOCKNUMBER","unwrap","BN_ZERO","l","logger","_healthTimer","_registries","_updateSub","_onProviderConnect","_onProviderDisconnect","_onProviderError","Init","options","type","decorateMethod","writable","emit","_isConnected","next","Promise","all","_loadMeta","_options","initWasm","resolve","cryptoWaitReady","hasMeta","cryptoReady","_isReady","setInterval","_rpcCore","system","health","toPromise","catch","error","Error","message","clearInterval","hasSubscriptions","warn","registry","setKnownTypes","source","registerTypes","types","_rpc","_decorateRpc","_decorateMethod","_rx","rpc","_rxDecorateMethod","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","hash","getBlockRegistry","provider","on","isConnected","chain","version","chainProps","setChainProperties","getChainProperties","register","getSpecTypes","specName","specVersion","knownTypes","typesBundle","typesAlias","getSpecAlias","blockHash","lastBlockHash","u8aToU8a","existingViaHash","find","r","u8aEq","assert","_genesisHash","_runtimeVersion","eq","number","parentHash","getHeader","header","isEmpty","getUpgradeVersion","firstVersion","lastVersion","state","getRuntimeVersion","existingViaVersion","_initRegistry","TypeRegistry","_runtimeChain","getMetadata","metadata","result","isDefault","metadataConsts","setMetadata","push","getBlockHash","genesisHash","unsubscribe","_this$_options$source","_metaFromSource","_metaFromChain","_runtimeMetadata","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","runtimeVersion","methods","keys","forEach","section","method","_filterRpcMethods","runtimeMetadata","subscribeRuntimeVersion","pipe","switchMap","_this$_runtimeVersion","of","map","log","toString","transactionVersion","thisRegistry","init","injectMetadata","subscribe","optMetadata","properties","_subscribeUpdates","_filterRpc","metadataKey","_this$_genesisHash","toHex","Metadata","length","getUniqTypes","metaExtrinsic","asLatest","extrinsic","gt","toNumber","getBlock","block","extrinsics","firstTx","LATEST_EXTRINSIC_VERSION","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _Extrinsic = require(\"@polkadot/types/extrinsic/Extrinsic\");\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Decorate = _interopRequireDefault(require(\"./Decorate\"));\n\n// Copyright 2017-2020 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst KEEPALIVE_INTERVAL = 15000;\nconst DEFAULT_BLOCKNUMBER = {\n  unwrap: () => _util.BN_ZERO\n};\nconst l = (0, _util.logger)('api/init');\n\nvar _healthTimer = (0, _classPrivateFieldLooseKey2.default)(\"healthTimer\");\n\nvar _registries = (0, _classPrivateFieldLooseKey2.default)(\"registries\");\n\nvar _updateSub = (0, _classPrivateFieldLooseKey2.default)(\"updateSub\");\n\nvar _onProviderConnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderConnect\");\n\nvar _onProviderDisconnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderDisconnect\");\n\nvar _onProviderError = (0, _classPrivateFieldLooseKey2.default)(\"onProviderError\");\n\nclass Init extends _Decorate.default {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : (0, _utilCrypto.cryptoWaitReady)()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(() => {// ignore\n            });\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        if ((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]) {\n          clearInterval((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]);\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n\n    if (!this.hasSubscriptions) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // all injected types added to the registry for overrides\n\n\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries] = (0, _classPrivateFieldLooseBase2.default)(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    this._queryMulti = this._decorateMulti(this._decorateMethod);\n    this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(hash => this.getBlockRegistry(hash));\n\n    this._rpcCore.provider.on('disconnected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n    this._rpcCore.provider.on('error', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderError)[_onProviderError]);\n\n    this._rpcCore.provider.on('connected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]); // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register((0, _typesKnown.getSpecTypes)(registry, chain, version.specName, version.specVersion)); // for bundled types, pull through the aliasses defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = (0, _typesKnown.getSpecAlias)(registry, chain, version.specName);\n    }\n\n    return registry;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    // shortcut in the case where we have an immediate-same request\n    const lastBlockHash = (0, _util.u8aToU8a)(blockHash);\n\n    const existingViaHash = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.lastBlockHash && (0, _util.u8aEq)(lastBlockHash, r.lastBlockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    (0, _util.assert)(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this._genesisHash.eq(blockHash) ? {\n      number: DEFAULT_BLOCKNUMBER,\n      parentHash: this._genesisHash\n    } : await this._rpcCore.chain.getHeader(blockHash).toPromise();\n    (0, _util.assert)((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = (0, _typesKnown.getUpgradeVersion)(this._genesisHash, header.number.unwrap());\n    const version = firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise(); // check for pre-existing registries\n\n    const existingViaVersion = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = lastBlockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = this._initRegistry(new _types.TypeRegistry(), this._runtimeChain, version);\n\n    const metadata = await this._rpcCore.state.getMetadata(header.parentHash).toPromise();\n    const result = {\n      isDefault: false,\n      lastBlockHash,\n      metadata,\n      metadataConsts: null,\n      registry,\n      specVersion: version.specVersion\n    };\n    registry.setMetadata(metadata);\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push(result);\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    const genesisHash = await this._rpcCore.chain.getBlockHash(0).toPromise(); // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n    if (this._isReady && !this._options.source && genesisHash.eq(this._genesisHash)) {\n      return true;\n    }\n\n    if (this._genesisHash) {\n      l.warn('Connection to new genesis detected, re-initializing');\n    }\n\n    this._genesisHash = genesisHash;\n\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub].unsubscribe();\n    }\n\n    const {\n      metadata = {}\n    } = this._options; // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n    this._runtimeMetadata = ((_this$_options$source = this._options.source) === null || _this$_options$source === void 0 ? void 0 : _this$_options$source._isReady) ? await this._metaFromSource(this._options.source) : await this._metaFromChain(metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    this._genesisHash = source.genesisHash;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return source.runtimeMetadata;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _operators.switchMap)(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        ((_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specVersion.eq(version.specVersion)) ? (0, _rxjs.of)(false) : this._rpcCore.state.getMetadata().pipe((0, _operators.map)(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(({\n            isDefault\n          }) => isDefault);\n\n          (0, _util.assert)(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.metadataConsts = null;\n          thisRegistry.registry.setMetadata(metadata);\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version);\n\n          this.injectMetadata(metadata, false, thisRegistry.registry);\n          return true;\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    var _this$_genesisHash;\n\n    const [runtimeVersion, chain, chainProps] = await Promise.all([this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // initializes the registry\n\n    this._initRegistry(this.registry, chain, runtimeVersion, chainProps);\n\n    this._subscribeUpdates(); // filter the RPC methods (this does an rpc-methods call)\n\n\n    await this._filterRpc(); // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${((_this$_genesisHash = this._genesisHash) === null || _this$_genesisHash === void 0 ? void 0 : _this$_genesisHash.toHex()) || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = metadataKey in optMetadata ? new _types.Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise();\n    this.registry.setMetadata(metadata); // setup the initial registry, when we have none\n\n    if (!(0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].length) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push({\n        isDefault: true,\n        lastBlockHash: null,\n        metadata,\n        metadataConsts: null,\n        registry: this.registry,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(false);\n    return metadata;\n  }\n\n  async _initFromMeta(metadata) {\n    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)\n\n    if (metaExtrinsic.version.gt(_util.BN_ZERO)) {\n      this._extrinsicType = metaExtrinsic.version.toNumber();\n    } else if (!this._options.source) {\n      // detect the extrinsic version in-use based on the last block\n      const {\n        block: {\n          extrinsics: [firstTx]\n        }\n      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values\n\n      this._extrinsicType = firstTx ? firstTx.type : _Extrinsic.LATEST_EXTRINSIC_VERSION;\n    }\n\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion;\n    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n\n}\n\nexports.default = Init;"]},"metadata":{},"sourceType":"script"}