{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _defaults = require(\"./defaults\");\n\nvar _pair = _interopRequireDefault(require(\"./pair\"));\n\nvar _pairs2 = _interopRequireDefault(require(\"./pairs\")); // Copyright 2017-2020 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nvar keypairFromSeed = {\n  ecdsa: function ecdsa(seed) {\n    return (0, _utilCrypto.secp256k1KeypairFromSeed)(seed);\n  },\n  ed25519: function ed25519(seed) {\n    return (0, _utilCrypto.naclKeypairFromSeed)(seed);\n  },\n  ethereum: function ethereum(seed) {\n    return (0, _utilCrypto.secp256k1KeypairFromSeed)(seed);\n  },\n  sr25519: function sr25519(seed) {\n    return (0, _utilCrypto.schnorrkelKeypairFromSeed)(seed);\n  }\n};\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\n\nvar _pairs = (0, _classPrivateFieldLooseKey2.default)(\"pairs\");\n\nvar _type = (0, _classPrivateFieldLooseKey2.default)(\"type\");\n\nvar _ss = (0, _classPrivateFieldLooseKey2.default)(\"ss58\");\n\nvar Keyring = /*#__PURE__*/function () {\n  function Keyring() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Keyring);\n\n    Object.defineProperty(this, _pairs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ss, {\n      writable: true,\n      value: void 0\n    });\n    this.decodeAddress = _utilCrypto.decodeAddress;\n\n    this.encodeAddress = function (address, ss58Format) {\n      return (0, _utilCrypto.encodeAddress)(address, (0, _util.isUndefined)(ss58Format) ? (0, _classPrivateFieldLooseBase2.default)(_this, _ss)[_ss] : ss58Format);\n    };\n\n    options.type = options.type || 'ed25519';\n    (0, _util.assert)(options && ['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined'), \"Expected a keyring type of either 'ed25519', 'sr25519' or 'ecdsa', found '\".concat(options.type));\n    (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs] = new _pairs2.default();\n    (0, _classPrivateFieldLooseBase2.default)(this, _ss)[_ss] = options.ss58Format;\n    (0, _classPrivateFieldLooseBase2.default)(this, _type)[_type] = options.type;\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n\n\n  _createClass(Keyring, [{\n    key: \"addPair\",\n\n    /**\n     * @name addPair\n     * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     */\n    value: function addPair(pair) {\n      return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].add(pair);\n    }\n    /**\n     * @name addFromAddress\n     * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to explicitely provide separate inputs including account address or public key, and optionally\n     * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from them that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromAddress\",\n    value: function addFromAddress(address) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var encoded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.type;\n      var ignoreChecksum = arguments.length > 4 ? arguments[4] : undefined;\n      var encType = arguments.length > 5 ? arguments[5] : undefined;\n      var publicKey = this.decodeAddress(address, ignoreChecksum);\n      return this.addPair((0, _pair.default)({\n        toSS58: this.encodeAddress,\n        type: type\n      }, {\n        publicKey: publicKey,\n        secretKey: new Uint8Array()\n      }, meta, encoded, encType));\n    }\n    /**\n     * @name addFromJson\n     * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromJson\",\n    value: function addFromJson(json, ignoreChecksum) {\n      return this.addPair(this.createFromJson(json, ignoreChecksum));\n    }\n    /**\n     * @name addFromMnemonic\n     * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n     * argument and a metadata argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromMnemonic\",\n    value: function addFromMnemonic(mnemonic) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return this.addFromUri(mnemonic, meta, type);\n    }\n    /**\n     * @name addFromSeed\n     * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n     * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n     * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromSeed\",\n    value: function addFromSeed(seed) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return this.addPair((0, _pair.default)({\n        toSS58: this.encodeAddress,\n        type: type\n      }, keypairFromSeed[type](seed), meta, null));\n    }\n    /**\n     * @name addFromUri\n     * @summary Creates an account via an suri\n     * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n     */\n\n  }, {\n    key: \"addFromUri\",\n    value: function addFromUri(suri) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return this.addPair(this.createFromUri(suri, meta, type));\n    }\n    /**\n     * @name createFromJson\n     * @description Creates a pair from a JSON keyfile\n     */\n\n  }, {\n    key: \"createFromJson\",\n    value: function createFromJson(_ref, ignoreChecksum) {\n      var address = _ref.address,\n          encoded = _ref.encoded,\n          _ref$encoding = _ref.encoding,\n          content = _ref$encoding.content,\n          type = _ref$encoding.type,\n          version = _ref$encoding.version,\n          meta = _ref.meta;\n      var cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n      var encType = !Array.isArray(type) ? [type] : type;\n      var publicKey = (0, _util.isHex)(address) ? (0, _util.hexToU8a)(address) : this.decodeAddress(address, ignoreChecksum);\n      var decoded = (0, _util.isHex)(encoded) ? (0, _util.hexToU8a)(encoded) : (0, _utilCrypto.base64Decode)(encoded);\n      return (0, _pair.default)({\n        toSS58: this.encodeAddress,\n        type: cryptoType\n      }, {\n        publicKey: publicKey,\n        secretKey: new Uint8Array()\n      }, meta, decoded, encType);\n    }\n    /**\n     * @name createFromUri\n     * @summary Creates a Keypair from an suri\n     * @description This creates a pair from the suri, but does not add it to the keyring\n     */\n\n  }, {\n    key: \"createFromUri\",\n    value: function createFromUri(_suri) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      // here we only aut-add the dev phrase if we have a hard-derived path\n      var suri = _suri.startsWith('//') ? \"\".concat(_defaults.DEV_PHRASE).concat(_suri) : _suri;\n\n      var _ref2 = (0, _utilCrypto.keyExtractSuri)(suri),\n          password = _ref2.password,\n          path = _ref2.path,\n          phrase = _ref2.phrase;\n\n      var seed;\n\n      if ((0, _util.isHex)(phrase, 256)) {\n        seed = (0, _util.hexToU8a)(phrase);\n      } else {\n        var str = phrase;\n        var parts = str.split(' ');\n\n        if ([12, 15, 18, 21, 24].includes(parts.length)) {\n          seed = type === 'ethereum' ? (0, _utilCrypto.mnemonicToLegacySeed)(phrase) : (0, _utilCrypto.mnemonicToMiniSecret)(phrase, password);\n        } else {\n          (0, _util.assert)(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n          seed = (0, _util.stringToU8a)(str.padEnd(32));\n        }\n      } // FIXME Need to support Ethereum-type derivation paths\n\n\n      var derived = (0, _utilCrypto.keyFromPath)(keypairFromSeed[type](seed), path, type);\n      return (0, _pair.default)({\n        toSS58: this.encodeAddress,\n        type: type\n      }, derived, meta, null);\n    }\n    /**\n     * @name encodeAddress\n     * @description Encodes the input into an ss58 representation\n     */\n\n    /**\n     * @name getPair\n     * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n     * @description Returns a keyring pair value from the keyring pair dictionary by performing\n     * a key lookup using the provided account address or public key (after decoding it).\n     */\n\n  }, {\n    key: \"getPair\",\n    value: function getPair(address) {\n      return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].get(address);\n    }\n    /**\n     * @name getPairs\n     * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n     * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n     */\n\n  }, {\n    key: \"getPairs\",\n    value: function getPairs() {\n      return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].all();\n    }\n    /**\n     * @name getPublicKeys\n     * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n     * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n     */\n\n  }, {\n    key: \"getPublicKeys\",\n    value: function getPublicKeys() {\n      return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].all().map(function (_ref3) {\n        var publicKey = _ref3.publicKey;\n        return publicKey;\n      });\n    }\n    /**\n     * @name removePair\n     * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n     */\n\n  }, {\n    key: \"removePair\",\n    value: function removePair(address) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].remove(address);\n    }\n    /**\n     * @name setSS58Format;\n     * @description Sets the ss58 format for the keyring\n     */\n\n  }, {\n    key: \"setSS58Format\",\n    value: function setSS58Format(ss58) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _ss)[_ss] = ss58;\n    }\n    /**\n     * @name toJson\n     * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n     * @description Returns a JSON object containing the metadata associated with an account\n     * when valid address or public key and when the account passphrase is provided if the account secret\n     * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n     * may backup their account to a JSON file that contains this information.\n     */\n\n  }, {\n    key: \"toJson\",\n    value: function toJson(address, passphrase) {\n      return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].get(address).toJson(passphrase);\n    }\n  }, {\n    key: \"pairs\",\n    get: function get() {\n      return this.getPairs();\n    }\n    /**\n     * @description retrieve the publicKeys (alias for getPublicKeys)\n     */\n\n  }, {\n    key: \"publicKeys\",\n    get: function get() {\n      return this.getPublicKeys();\n    }\n    /**\n     * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return (0, _classPrivateFieldLooseBase2.default)(this, _type)[_type];\n    }\n  }]);\n\n  return Keyring;\n}();\n\nexports.default = Keyring;","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/keyring/keyring.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_classPrivateFieldLooseBase2","_classPrivateFieldLooseKey2","_util","_utilCrypto","_defaults","_pair","_pairs2","keypairFromSeed","ecdsa","seed","secp256k1KeypairFromSeed","ed25519","naclKeypairFromSeed","ethereum","sr25519","schnorrkelKeypairFromSeed","_pairs","_type","_ss","Keyring","options","writable","decodeAddress","encodeAddress","address","ss58Format","isUndefined","type","assert","includes","pair","add","meta","encoded","ignoreChecksum","encType","publicKey","addPair","toSS58","secretKey","Uint8Array","json","createFromJson","mnemonic","addFromUri","suri","createFromUri","encoding","content","version","cryptoType","Array","isArray","isHex","hexToU8a","decoded","base64Decode","_suri","startsWith","DEV_PHRASE","keyExtractSuri","password","path","phrase","str","parts","split","length","mnemonicToLegacySeed","mnemonicToMiniSecret","stringToU8a","padEnd","derived","keyFromPath","get","all","map","remove","ss58","passphrase","toJson","getPairs","getPublicKeys"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _defaults = require(\"./defaults\");\n\nvar _pair = _interopRequireDefault(require(\"./pair\"));\n\nvar _pairs2 = _interopRequireDefault(require(\"./pairs\"));\n\n// Copyright 2017-2020 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst keypairFromSeed = {\n  ecdsa: seed => (0, _utilCrypto.secp256k1KeypairFromSeed)(seed),\n  ed25519: seed => (0, _utilCrypto.naclKeypairFromSeed)(seed),\n  ethereum: seed => (0, _utilCrypto.secp256k1KeypairFromSeed)(seed),\n  sr25519: seed => (0, _utilCrypto.schnorrkelKeypairFromSeed)(seed)\n};\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\n\nvar _pairs = (0, _classPrivateFieldLooseKey2.default)(\"pairs\");\n\nvar _type = (0, _classPrivateFieldLooseKey2.default)(\"type\");\n\nvar _ss = (0, _classPrivateFieldLooseKey2.default)(\"ss58\");\n\nclass Keyring {\n  constructor(options = {}) {\n    Object.defineProperty(this, _pairs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ss, {\n      writable: true,\n      value: void 0\n    });\n    this.decodeAddress = _utilCrypto.decodeAddress;\n\n    this.encodeAddress = (address, ss58Format) => {\n      return (0, _utilCrypto.encodeAddress)(address, (0, _util.isUndefined)(ss58Format) ? (0, _classPrivateFieldLooseBase2.default)(this, _ss)[_ss] : ss58Format);\n    };\n\n    options.type = options.type || 'ed25519';\n    (0, _util.assert)(options && ['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined'), `Expected a keyring type of either 'ed25519', 'sr25519' or 'ecdsa', found '${options.type}`);\n    (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs] = new _pairs2.default();\n    (0, _classPrivateFieldLooseBase2.default)(this, _ss)[_ss] = options.ss58Format;\n    (0, _classPrivateFieldLooseBase2.default)(this, _type)[_type] = options.type;\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n\n\n  get pairs() {\n    return this.getPairs();\n  }\n  /**\n   * @description retrieve the publicKeys (alias for getPublicKeys)\n   */\n\n\n  get publicKeys() {\n    return this.getPublicKeys();\n  }\n  /**\n   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n   */\n\n\n  get type() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _type)[_type];\n  }\n  /**\n   * @name addPair\n   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   */\n\n\n  addPair(pair) {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].add(pair);\n  }\n  /**\n   * @name addFromAddress\n   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to explicitely provide separate inputs including account address or public key, and optionally\n   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from them that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n    const publicKey = this.decodeAddress(address, ignoreChecksum);\n    return this.addPair((0, _pair.default)({\n      toSS58: this.encodeAddress,\n      type\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, encoded, encType));\n  }\n  /**\n   * @name addFromJson\n   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromJson(json, ignoreChecksum) {\n    return this.addPair(this.createFromJson(json, ignoreChecksum));\n  }\n  /**\n   * @name addFromMnemonic\n   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n   * argument and a metadata argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromMnemonic(mnemonic, meta = {}, type = this.type) {\n    return this.addFromUri(mnemonic, meta, type);\n  }\n  /**\n   * @name addFromSeed\n   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromSeed(seed, meta = {}, type = this.type) {\n    return this.addPair((0, _pair.default)({\n      toSS58: this.encodeAddress,\n      type\n    }, keypairFromSeed[type](seed), meta, null));\n  }\n  /**\n   * @name addFromUri\n   * @summary Creates an account via an suri\n   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n   */\n\n\n  addFromUri(suri, meta = {}, type = this.type) {\n    return this.addPair(this.createFromUri(suri, meta, type));\n  }\n  /**\n   * @name createFromJson\n   * @description Creates a pair from a JSON keyfile\n   */\n\n\n  createFromJson({\n    address,\n    encoded,\n    encoding: {\n      content,\n      type,\n      version\n    },\n    meta\n  }, ignoreChecksum) {\n    const cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n    const encType = !Array.isArray(type) ? [type] : type;\n    const publicKey = (0, _util.isHex)(address) ? (0, _util.hexToU8a)(address) : this.decodeAddress(address, ignoreChecksum);\n    const decoded = (0, _util.isHex)(encoded) ? (0, _util.hexToU8a)(encoded) : (0, _utilCrypto.base64Decode)(encoded);\n    return (0, _pair.default)({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, decoded, encType);\n  }\n  /**\n   * @name createFromUri\n   * @summary Creates a Keypair from an suri\n   * @description This creates a pair from the suri, but does not add it to the keyring\n   */\n\n\n  createFromUri(_suri, meta = {}, type = this.type) {\n    // here we only aut-add the dev phrase if we have a hard-derived path\n    const suri = _suri.startsWith('//') ? `${_defaults.DEV_PHRASE}${_suri}` : _suri;\n    const {\n      password,\n      path,\n      phrase\n    } = (0, _utilCrypto.keyExtractSuri)(suri);\n    let seed;\n\n    if ((0, _util.isHex)(phrase, 256)) {\n      seed = (0, _util.hexToU8a)(phrase);\n    } else {\n      const str = phrase;\n      const parts = str.split(' ');\n\n      if ([12, 15, 18, 21, 24].includes(parts.length)) {\n        seed = type === 'ethereum' ? (0, _utilCrypto.mnemonicToLegacySeed)(phrase) : (0, _utilCrypto.mnemonicToMiniSecret)(phrase, password);\n      } else {\n        (0, _util.assert)(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n        seed = (0, _util.stringToU8a)(str.padEnd(32));\n      }\n    } // FIXME Need to support Ethereum-type derivation paths\n\n\n    const derived = (0, _utilCrypto.keyFromPath)(keypairFromSeed[type](seed), path, type);\n    return (0, _pair.default)({\n      toSS58: this.encodeAddress,\n      type\n    }, derived, meta, null);\n  }\n  /**\n   * @name encodeAddress\n   * @description Encodes the input into an ss58 representation\n   */\n\n\n  /**\n   * @name getPair\n   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n   * @description Returns a keyring pair value from the keyring pair dictionary by performing\n   * a key lookup using the provided account address or public key (after decoding it).\n   */\n  getPair(address) {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].get(address);\n  }\n  /**\n   * @name getPairs\n   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPairs() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].all();\n  }\n  /**\n   * @name getPublicKeys\n   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPublicKeys() {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].all().map(({\n      publicKey\n    }) => publicKey);\n  }\n  /**\n   * @name removePair\n   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n   */\n\n\n  removePair(address) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].remove(address);\n  }\n  /**\n   * @name setSS58Format;\n   * @description Sets the ss58 format for the keyring\n   */\n\n\n  setSS58Format(ss58) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _ss)[_ss] = ss58;\n  }\n  /**\n   * @name toJson\n   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n   * @description Returns a JSON object containing the metadata associated with an account\n   * when valid address or public key and when the account passphrase is provided if the account secret\n   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n   * may backup their account to a JSON file that contains this information.\n   */\n\n\n  toJson(address, passphrase) {\n    return (0, _classPrivateFieldLooseBase2.default)(this, _pairs)[_pairs].get(address).toJson(passphrase);\n  }\n\n}\n\nexports.default = Keyring;"]},"metadata":{},"sourceType":"script"}