{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _memoizee = _interopRequireDefault(require(\"memoizee\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _jsonrpc = _interopRequireDefault(require(\"@polkadot/types/interfaces/jsonrpc\"));\n\nvar _types = require(\"@polkadot/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _normalizer = _interopRequireDefault(require(\"./normalizer\"));\n\nvar _rxjs2 = require(\"./rxjs\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar l = (0, _util.logger)('rpc-core');\nvar EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, _ref, error) {\n  var params = _ref.params,\n      type = _ref.type;\n  var inputs = params.map(function (_ref2) {\n    var isOptional = _ref2.isOptional,\n        name = _ref2.name,\n        type = _ref2.type;\n    return \"\".concat(name).concat(isOptional ? '?' : '', \": \").concat(type);\n  }).join(', ');\n  l.error(\"\".concat(method, \"(\").concat(inputs, \"): \").concat(type, \":: \").concat(error.message));\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import WsProvider from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nvar _instanceId = (0, _classPrivateFieldLooseKey2.default)(\"instanceId\");\n\nvar _registryDefault = (0, _classPrivateFieldLooseKey2.default)(\"registryDefault\");\n\nvar _getBlockRegistry = (0, _classPrivateFieldLooseKey2.default)(\"getBlockRegistry\");\n\nvar _storageCache = (0, _classPrivateFieldLooseKey2.default)(\"storageCache\");\n\nvar Rpc = /*#__PURE__*/function () {\n  // Ok, this is quite horrible - we really should not be using the ! here, but we are actually assigning\n  // these via the createInterfaces inside the constructor. However... this is not quite visible. The reason\n  // why we don't do for individual assignments is to allow user-defined RPCs to also be defined\n\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  function Rpc(instanceId, registry, provider) {\n    var _this$sections;\n\n    var userRpc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, Rpc);\n\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registryDefault, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getBlockRegistry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.sections = [];\n    this.author = void 0;\n    this.babe = void 0;\n    this.chain = void 0;\n    this.childstate = void 0;\n    this.contracts = void 0;\n    this.engine = void 0;\n    this.grandpa = void 0;\n    this.offchain = void 0;\n    this.payment = void 0;\n    this.rpc = void 0;\n    this.state = void 0;\n    this.system = void 0; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');\n    (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] = instanceId;\n    (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault] = registry;\n    this.provider = provider;\n    var sectionNames = Object.keys(_jsonrpc.default); // these are the base keys (i.e. part of jsonrpc)\n\n    (_this$sections = this.sections).push.apply(_this$sections, _toConsumableArray(sectionNames));\n\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n\n\n  _createClass(Rpc, [{\n    key: \"connect\",\n\n    /**\n     * @description Manually connect from the attached provider\n     */\n    value: function connect() {\n      return this.provider.connect();\n    }\n    /**\n     * @description Manually disconnect from the attached provider\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return this.provider.disconnect();\n    }\n    /**\n     * @description Sets a registry swap (typically from Api)\n     */\n\n  }, {\n    key: \"setRegistrySwap\",\n    value: function setRegistrySwap(registrySwap) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] = registrySwap;\n    }\n  }, {\n    key: \"addUserInterfaces\",\n    value: function addUserInterfaces(userRpc) {\n      var _this$sections2,\n          _this = this;\n\n      // add any extra user-defined sections\n      (_this$sections2 = this.sections).push.apply(_this$sections2, _toConsumableArray(Object.keys(userRpc).filter(function (key) {\n        return !_this.sections.includes(key);\n      }))); // decorate the sections with base and user methods\n\n\n      this.sections.forEach(function (sectionName) {\n        if (!_this[sectionName]) {\n          _this[sectionName] = {};\n        }\n\n        var section = _this[sectionName];\n        Object.entries(_objectSpread(_objectSpread({}, _this._createInterface(sectionName, _jsonrpc.default[sectionName] || {})), _this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              key = _ref4[0],\n              value = _ref4[1];\n\n          // we don't want to clobber existing, i.e. when this is called again after chain is determined\n          if (!section[key]) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            section[key] = value;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_createInterface\",\n    value: function _createInterface(section, methods) {\n      var _this2 = this;\n\n      return Object.keys(methods).filter(function (method) {\n        return !_this2.mapping.has(\"\".concat(section, \"_\").concat(method));\n      }).reduce(function (exposed, method) {\n        var def = methods[method];\n        var isSubscription = !!def.pubsub;\n\n        _this2.mapping.set(\"\".concat(section, \"_\").concat(method), _objectSpread(_objectSpread({}, def), {}, {\n          isSubscription: isSubscription,\n          jsonrpc: \"\".concat(section, \"_\").concat(method),\n          method: method,\n          section: section\n        })); // FIXME Remove any here\n        // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor\n        // every method inside this class to take:\n        // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`\n        // Not doing so, because it makes this class a little bit less readable,\n        // and leaving it as-is doesn't harm much\n\n\n        exposed[method] = isSubscription ? _this2._createMethodSubscribe(section, method, def) : _this2._createMethodSend(section, method, def);\n        return exposed;\n      }, {});\n    }\n  }, {\n    key: \"_createMethodWithRaw\",\n    value: function _createMethodWithRaw(creator) {\n      var call = creator(false);\n      call.raw = creator(true);\n      return call;\n    }\n  }, {\n    key: \"_createMethodSend\",\n    value: function _createMethodSend(section, method, def) {\n      var _this3 = this;\n\n      var rpcName = \"\".concat(section, \"_\").concat(method);\n      var hashIndex = def.params.findIndex(function (_ref5) {\n        var isHistoric = _ref5.isHistoric;\n        return isHistoric;\n      });\n      var cacheIndex = def.params.findIndex(function (_ref6) {\n        var isCached = _ref6.isCached;\n        return isCached;\n      });\n      var memoized = null; // execute the RPC call, doing a registry swap for historic as applicable\n\n      var callWithRegistry = /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(isRaw, values) {\n          var hash, _ref8, registry, params, data;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  hash = hashIndex === -1 ? undefined : values[hashIndex];\n\n                  if (!(hash && (0, _classPrivateFieldLooseBase2.default)(_this3, _getBlockRegistry)[_getBlockRegistry])) {\n                    _context.next = 7;\n                    break;\n                  }\n\n                  _context.next = 4;\n                  return (0, _classPrivateFieldLooseBase2.default)(_this3, _getBlockRegistry)[_getBlockRegistry](hash);\n\n                case 4:\n                  _context.t0 = _context.sent;\n                  _context.next = 8;\n                  break;\n\n                case 7:\n                  _context.t0 = {\n                    registry: (0, _classPrivateFieldLooseBase2.default)(_this3, _registryDefault)[_registryDefault]\n                  };\n\n                case 8:\n                  _ref8 = _context.t0;\n                  registry = _ref8.registry;\n                  params = _this3._formatInputs(registry, def, values);\n                  _context.next = 13;\n                  return _this3.provider.send(rpcName, params.map(function (param) {\n                    return param.toJSON();\n                  }));\n\n                case 13:\n                  data = _context.sent;\n                  return _context.abrupt(\"return\", isRaw ? registry.createType('Raw', data) : _this3._formatOutput(registry, method, def, params, data));\n\n                case 15:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function callWithRegistry(_x, _x2) {\n          return _ref7.apply(this, arguments);\n        };\n      }();\n\n      var creator = function creator(isRaw) {\n        return function () {\n          for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n            values[_key] = arguments[_key];\n          }\n\n          var isDelayed = hashIndex !== -1 && !!values[hashIndex] || cacheIndex !== -1 && !!values[cacheIndex];\n          return new _rxjs.Observable(function (observer) {\n            callWithRegistry(isRaw, values).then(function (value) {\n              observer.next(value);\n              observer.complete();\n            }).catch(function (error) {\n              logErrorMessage(method, def, error);\n              observer.error(error);\n              observer.complete();\n            });\n            return function () {\n              var _memoized3;\n\n              var _memoized; // delete old results from cache\n\n\n              (_memoized = memoized) === null || _memoized === void 0 ? void 0 : (_memoized3 = _memoized).delete.apply(_memoized3, values);\n            };\n          }).pipe((0, _operators.publishReplay)(1), // create a Replay(1)\n          isDelayed ? (0, _rxjs2.refCountDelay)() // Unsubscribe after delay\n          : (0, _operators.refCount)());\n        };\n      };\n\n      memoized = (0, _memoizee.default)(this._createMethodWithRaw(creator), {\n        length: false,\n        normalizer: (0, _normalizer.default)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId])\n      });\n      return memoized;\n    } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n  }, {\n    key: \"_createSubscriber\",\n    value: function _createSubscriber(_ref9, errorHandler) {\n      var _this4 = this;\n\n      var paramsJson = _ref9.paramsJson,\n          subName = _ref9.subName,\n          subType = _ref9.subType,\n          update = _ref9.update;\n      return new Promise(function (resolve, reject) {\n        _this4.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(function (error) {\n          errorHandler(error);\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: \"_createMethodSubscribe\",\n    value: function _createMethodSubscribe(section, method, def) {\n      var _this5 = this;\n\n      var _def$pubsub = _slicedToArray(def.pubsub, 3),\n          updateType = _def$pubsub[0],\n          subMethod = _def$pubsub[1],\n          unsubMethod = _def$pubsub[2];\n\n      var subName = \"\".concat(section, \"_\").concat(subMethod);\n      var unsubName = \"\".concat(section, \"_\").concat(unsubMethod);\n      var subType = \"\".concat(section, \"_\").concat(updateType);\n      var memoized = null;\n\n      var creator = function creator(isRaw) {\n        return function () {\n          for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            values[_key2] = arguments[_key2];\n          }\n\n          return new _rxjs.Observable(function (observer) {\n            // Have at least an empty promise, as used in the unsubscribe\n            var subscriptionPromise = Promise.resolve(null);\n\n            var registry = (0, _classPrivateFieldLooseBase2.default)(_this5, _registryDefault)[_registryDefault];\n\n            var errorHandler = function errorHandler(error) {\n              logErrorMessage(method, def, error);\n              observer.error(error);\n            };\n\n            try {\n              var params = _this5._formatInputs(registry, def, values);\n\n              var paramsJson = params.map(function (param) {\n                return param.toJSON();\n              });\n\n              var update = function update(error, result) {\n                if (error) {\n                  logErrorMessage(method, def, error);\n                  return;\n                }\n\n                try {\n                  observer.next(isRaw ? registry.createType('Raw', result) : _this5._formatOutput(registry, method, def, params, result));\n                } catch (error) {\n                  observer.error(error);\n                }\n              };\n\n              subscriptionPromise = _this5._createSubscriber({\n                paramsJson: paramsJson,\n                subName: subName,\n                subType: subType,\n                update: update\n              }, errorHandler);\n            } catch (error) {\n              errorHandler(error);\n            } // Teardown logic\n\n\n            return function () {\n              var _memoized4;\n\n              var _memoized2; // Delete from cache, so old results don't hang around\n\n\n              (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : (_memoized4 = _memoized2).delete.apply(_memoized4, values); // Unsubscribe from provider\n\n              subscriptionPromise.then(function (subscriptionId) {\n                return (0, _util.isNull)(subscriptionId) ? Promise.resolve(false) : _this5.provider.unsubscribe(subType, unsubName, subscriptionId);\n              }).catch(function (error) {\n                return logErrorMessage(method, def, error);\n              });\n            };\n          }).pipe((0, _rxjs2.drr)());\n        };\n      };\n\n      memoized = (0, _memoizee.default)(this._createMethodWithRaw(creator), {\n        // Dynamic length for argument\n        length: false,\n        // Normalize args so that different args that should be cached\n        // together are cached together.\n        // E.g.: `query.my.method('abc') === query.my.method(createType('AccountId', 'abc'));`\n        normalizer: (0, _normalizer.default)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId])\n      });\n      return memoized;\n    }\n  }, {\n    key: \"_formatInputs\",\n    value: function _formatInputs(registry, def, inputs) {\n      var reqArgCount = def.params.filter(function (_ref10) {\n        var isOptional = _ref10.isOptional;\n        return !isOptional;\n      }).length;\n      var optText = reqArgCount === def.params.length ? '' : \" (\".concat(def.params.length - reqArgCount, \" optional)\");\n      (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= def.params.length, \"Expected \".concat(def.params.length, \" parameters\").concat(optText, \", \").concat(inputs.length, \" found instead\"));\n      return inputs.map(function (input, index) {\n        return (0, _types.createTypeUnsafe)(registry, def.params[index].type, [input]);\n      });\n    }\n  }, {\n    key: \"_treatAsHex\",\n    value: function _treatAsHex(key) {\n      // :code is problematic - it does not have the length attached, which is\n      // unlike all other storage entries where it is indeed properly encoded\n      return ['0x3a636f6465'].includes(key.toHex());\n    }\n  }, {\n    key: \"_formatOutput\",\n    value: function _formatOutput(registry, method, rpc, params, result) {\n      var _this6 = this;\n\n      if (rpc.type === 'StorageData') {\n        var key = params[0];\n\n        try {\n          return this._formatStorageData(registry, key, result);\n        } catch (error) {\n          console.error(\"Unable to decode storage \".concat(key.section || 'unknown', \".\").concat(key.method || 'unknown', \":\"), error.message);\n          throw error;\n        }\n      } else if (rpc.type === 'StorageChangeSet') {\n        var keys = params[0];\n        return keys ? this._formatStorageSet(registry, keys, result.changes) : registry.createType('StorageChangeSet', result);\n      } else if (rpc.type === 'Vec<StorageChangeSet>') {\n        var mapped = result.map(function (_ref11) {\n          var block = _ref11.block,\n              changes = _ref11.changes;\n          return [registry.createType('Hash', block), _this6._formatStorageSet(registry, params[0], changes)];\n        }); // we only query at a specific block, not a range - flatten\n\n        return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n      }\n\n      return (0, _types.createTypeUnsafe)(registry, rpc.type, [result]);\n    }\n  }, {\n    key: \"_formatStorageData\",\n    value: function _formatStorageData(registry, key, value) {\n      // single return value (via state.getStorage), decode the value based on the\n      // outputType that we have specified. Fallback to Raw on nothing\n      var type = key.outputType || 'Raw';\n      var meta = key.meta || EMPTY_META;\n      var isEmpty = (0, _util.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all\n      // data will be correctly encoded (incl. numbers, excl. :code)\n\n      var input = isEmpty ? null : this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value);\n\n      if (meta.modifier.isOptional) {\n        return new _types.Option(registry, (0, _types.createClass)(registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(registry, type, [input], true));\n      }\n\n      return (0, _types.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);\n    }\n  }, {\n    key: \"_formatStorageSet\",\n    value: function _formatStorageSet(registry, keys, changes) {\n      var _this7 = this;\n\n      // For StorageChangeSet, the changes has the [key, value] mappings\n      var withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n      // one at a time, all based on the query types. Three values can be returned -\n      //   - Codec - There is a valid value, non-empty\n      //   - null - The storage key is empty\n\n      return keys.reduce(function (results, key) {\n        try {\n          results.push(_this7._formatStorageSetEntry(registry, key, changes, withCache));\n        } catch (error) {\n          console.error(\"Unable to decode storage \".concat(key.section || 'unknown', \".\").concat(key.method || 'unknown', \":\"), error.message);\n          throw error;\n        }\n\n        return results;\n      }, []);\n    }\n  }, {\n    key: \"_formatStorageSetEntry\",\n    value: function _formatStorageSetEntry(registry, key, changes, witCache) {\n      // Fallback to Raw (i.e. just the encoding) if we don't have a specific type\n      var type = key.outputType || 'Raw';\n      var hexKey = key.toHex();\n      var meta = key.meta || EMPTY_META;\n      var found = changes.find(function (_ref12) {\n        var _ref13 = _slicedToArray(_ref12, 1),\n            key = _ref13[0];\n\n        return key === hexKey;\n      }); // if we don't find the value, this is our fallback\n      //   - in the case of an array of values, fill the hole from the cache\n      //   - if a single result value, don't fill - it is not an update hole\n      //   - fallback to an empty option in all cases\n\n      var value = (0, _util.isUndefined)(found) ? witCache && (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n      var isEmpty = (0, _util.isNull)(value);\n      var input = isEmpty || this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value); // store the retrieved result - the only issue with this cache is that there is no\n      // clearing of it, so very long running processes (not just a couple of hours, longer)\n      // will increase memory beyond what is allowed.\n\n      (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].set(hexKey, value);\n\n      if (meta.modifier.isOptional) {\n        return new _types.Option(registry, (0, _types.createClass)(registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(registry, type, [input], true));\n      }\n\n      return (0, _types.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.provider.isConnected;\n    }\n  }]);\n\n  return Rpc;\n}();\n\nexports.default = Rpc;","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project1/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/rpc-core/index.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_defineProperty2","_classPrivateFieldLooseBase2","_classPrivateFieldLooseKey2","_memoizee","_rxjs","_operators","_jsonrpc","_types","_util","_normalizer","_rxjs2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","l","logger","EMPTY_META","fallback","undefined","modifier","isOptional","type","asMap","linked","isTrue","isMap","logErrorMessage","method","error","params","inputs","map","name","join","message","_instanceId","_registryDefault","_getBlockRegistry","_storageCache","Rpc","instanceId","registry","provider","userRpc","writable","Map","mapping","sections","author","babe","chain","childstate","contracts","engine","grandpa","offchain","payment","rpc","state","system","assert","isFunction","send","sectionNames","addUserInterfaces","connect","disconnect","registrySwap","includes","sectionName","section","entries","_createInterface","methods","has","reduce","exposed","def","isSubscription","pubsub","set","jsonrpc","_createMethodSubscribe","_createMethodSend","creator","call","raw","rpcName","hashIndex","findIndex","isHistoric","cacheIndex","isCached","memoized","callWithRegistry","isRaw","values","hash","_formatInputs","param","toJSON","data","createType","_formatOutput","isDelayed","Observable","observer","then","next","complete","catch","_memoized","delete","pipe","publishReplay","refCountDelay","refCount","_createMethodWithRaw","normalizer","errorHandler","paramsJson","subName","subType","update","Promise","resolve","reject","subscribe","updateType","subMethod","unsubMethod","unsubName","subscriptionPromise","result","_createSubscriber","_memoized2","subscriptionId","isNull","unsubscribe","drr","reqArgCount","optText","input","index","createTypeUnsafe","toHex","_formatStorageData","console","_formatStorageSet","changes","mapped","block","outputType","meta","isEmpty","_treatAsHex","u8aToU8a","Option","createClass","hexToU8a","withCache","results","_formatStorageSetEntry","witCache","hexKey","found","find","isUndefined","get","isConnected"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _memoizee = _interopRequireDefault(require(\"memoizee\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _jsonrpc = _interopRequireDefault(require(\"@polkadot/types/interfaces/jsonrpc\"));\n\nvar _types = require(\"@polkadot/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _normalizer = _interopRequireDefault(require(\"./normalizer\"));\n\nvar _rxjs2 = require(\"./rxjs\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst l = (0, _util.logger)('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, {\n  params,\n  type\n}, error) {\n  const inputs = params.map(({\n    isOptional,\n    name,\n    type\n  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');\n  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import WsProvider from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nvar _instanceId = (0, _classPrivateFieldLooseKey2.default)(\"instanceId\");\n\nvar _registryDefault = (0, _classPrivateFieldLooseKey2.default)(\"registryDefault\");\n\nvar _getBlockRegistry = (0, _classPrivateFieldLooseKey2.default)(\"getBlockRegistry\");\n\nvar _storageCache = (0, _classPrivateFieldLooseKey2.default)(\"storageCache\");\n\nclass Rpc {\n  // Ok, this is quite horrible - we really should not be using the ! here, but we are actually assigning\n  // these via the createInterfaces inside the constructor. However... this is not quite visible. The reason\n  // why we don't do for individual assignments is to allow user-defined RPCs to also be defined\n\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  constructor(instanceId, registry, provider, userRpc = {}) {\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registryDefault, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getBlockRegistry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.sections = [];\n    this.author = void 0;\n    this.babe = void 0;\n    this.chain = void 0;\n    this.childstate = void 0;\n    this.contracts = void 0;\n    this.engine = void 0;\n    this.grandpa = void 0;\n    this.offchain = void 0;\n    this.payment = void 0;\n    this.rpc = void 0;\n    this.state = void 0;\n    this.system = void 0;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');\n    (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] = instanceId;\n    (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault] = registry;\n    this.provider = provider;\n    const sectionNames = Object.keys(_jsonrpc.default); // these are the base keys (i.e. part of jsonrpc)\n\n    this.sections.push(...sectionNames);\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n\n\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n\n\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n\n\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n\n\n  setRegistrySwap(registrySwap) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] = registrySwap;\n  }\n\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(key => !this.sections.includes(key))); // decorate the sections with base and user methods\n\n    this.sections.forEach(sectionName => {\n      if (!this[sectionName]) {\n        this[sectionName] = {};\n      }\n\n      const section = this[sectionName];\n      Object.entries(_objectSpread(_objectSpread({}, this._createInterface(sectionName, _jsonrpc.default[sectionName] || {})), this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(([key, value]) => {\n        // we don't want to clobber existing, i.e. when this is called again after chain is determined\n        if (!section[key]) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          section[key] = value;\n        }\n      });\n    });\n  }\n\n  _createInterface(section, methods) {\n    return Object.keys(methods).filter(method => !this.mapping.has(`${section}_${method}`)).reduce((exposed, method) => {\n      const def = methods[method];\n      const isSubscription = !!def.pubsub;\n      this.mapping.set(`${section}_${method}`, _objectSpread(_objectSpread({}, def), {}, {\n        isSubscription,\n        jsonrpc: `${section}_${method}`,\n        method,\n        section\n      })); // FIXME Remove any here\n      // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor\n      // every method inside this class to take:\n      // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`\n      // Not doing so, because it makes this class a little bit less readable,\n      // and leaving it as-is doesn't harm much\n\n      exposed[method] = isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def);\n      return exposed;\n    }, {});\n  }\n\n  _createMethodWithRaw(creator) {\n    const call = creator(false);\n    call.raw = creator(true);\n    return call;\n  }\n\n  _createMethodSend(section, method, def) {\n    const rpcName = `${section}_${method}`;\n    const hashIndex = def.params.findIndex(({\n      isHistoric\n    }) => isHistoric);\n    const cacheIndex = def.params.findIndex(({\n      isCached\n    }) => isCached);\n    let memoized = null; // execute the RPC call, doing a registry swap for historic as applicable\n\n    const callWithRegistry = async (isRaw, values) => {\n      const hash = hashIndex === -1 ? undefined : values[hashIndex];\n      const {\n        registry\n      } = hash && (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] ? await (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry](hash) : {\n        registry: (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault]\n      };\n\n      const params = this._formatInputs(registry, def, values);\n\n      const data = await this.provider.send(rpcName, params.map(param => param.toJSON()));\n      return isRaw ? registry.createType('Raw', data) : this._formatOutput(registry, method, def, params, data);\n    };\n\n    const creator = isRaw => (...values) => {\n      const isDelayed = hashIndex !== -1 && !!values[hashIndex] || cacheIndex !== -1 && !!values[cacheIndex];\n      return new _rxjs.Observable(observer => {\n        callWithRegistry(isRaw, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          var _memoized;\n\n          // delete old results from cache\n          (_memoized = memoized) === null || _memoized === void 0 ? void 0 : _memoized.delete(...values);\n        };\n      }).pipe((0, _operators.publishReplay)(1), // create a Replay(1)\n      isDelayed ? (0, _rxjs2.refCountDelay)() // Unsubscribe after delay\n      : (0, _operators.refCount)());\n    };\n\n    memoized = (0, _memoizee.default)(this._createMethodWithRaw(creator), {\n      length: false,\n      normalizer: (0, _normalizer.default)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId])\n    });\n    return memoized;\n  } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n\n  _createSubscriber({\n    paramsJson,\n    subName,\n    subType,\n    update\n  }, errorHandler) {\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n\n  _createMethodSubscribe(section, method, def) {\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n    let memoized = null;\n\n    const creator = isRaw => (...values) => {\n      return new _rxjs.Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n\n        const registry = (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault];\n\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n\n        try {\n          const params = this._formatInputs(registry, def, values);\n\n          const paramsJson = params.map(param => param.toJSON());\n\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n\n            try {\n              observer.next(isRaw ? registry.createType('Raw', result) : this._formatOutput(registry, method, def, params, result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n\n          subscriptionPromise = this._createSubscriber({\n            paramsJson,\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        } // Teardown logic\n\n\n        return () => {\n          var _memoized2;\n\n          // Delete from cache, so old results don't hang around\n          (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : _memoized2.delete(...values); // Unsubscribe from provider\n\n          subscriptionPromise.then(subscriptionId => (0, _util.isNull)(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe((0, _rxjs2.drr)());\n    };\n\n    memoized = (0, _memoizee.default)(this._createMethodWithRaw(creator), {\n      // Dynamic length for argument\n      length: false,\n      // Normalize args so that different args that should be cached\n      // together are cached together.\n      // E.g.: `query.my.method('abc') === query.my.method(createType('AccountId', 'abc'));`\n      normalizer: (0, _normalizer.default)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId])\n    });\n    return memoized;\n  }\n\n  _formatInputs(registry, def, inputs) {\n    const reqArgCount = def.params.filter(({\n      isOptional\n    }) => !isOptional).length;\n    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;\n    (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= def.params.length, `Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);\n    return inputs.map((input, index) => (0, _types.createTypeUnsafe)(registry, def.params[index].type, [input]));\n  }\n\n  _treatAsHex(key) {\n    // :code is problematic - it does not have the length attached, which is\n    // unlike all other storage entries where it is indeed properly encoded\n    return ['0x3a636f6465'].includes(key.toHex());\n  }\n\n  _formatOutput(registry, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n\n      try {\n        return this._formatStorageData(registry, key, result);\n      } catch (error) {\n        console.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:`, error.message);\n        throw error;\n      }\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const mapped = result.map(({\n        block,\n        changes\n      }) => [registry.createType('Hash', block), this._formatStorageSet(registry, params[0], changes)]); // we only query at a specific block, not a range - flatten\n\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n\n    return (0, _types.createTypeUnsafe)(registry, rpc.type, [result]);\n  }\n\n  _formatStorageData(registry, key, value) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const isEmpty = (0, _util.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n\n    const input = isEmpty ? null : this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value);\n\n    if (meta.modifier.isOptional) {\n      return new _types.Option(registry, (0, _types.createClass)(registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(registry, type, [input], true));\n    }\n\n    return (0, _types.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);\n  }\n\n  _formatStorageSet(registry, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n    // one at a time, all based on the query types. Three values can be returned -\n    //   - Codec - There is a valid value, non-empty\n    //   - null - The storage key is empty\n\n    return keys.reduce((results, key) => {\n      try {\n        results.push(this._formatStorageSetEntry(registry, key, changes, withCache));\n      } catch (error) {\n        console.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:`, error.message);\n        throw error;\n      }\n\n      return results;\n    }, []);\n  }\n\n  _formatStorageSetEntry(registry, key, changes, witCache) {\n    // Fallback to Raw (i.e. just the encoding) if we don't have a specific type\n    const type = key.outputType || 'Raw';\n    const hexKey = key.toHex();\n    const meta = key.meta || EMPTY_META;\n    const found = changes.find(([key]) => key === hexKey); // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n\n    const value = (0, _util.isUndefined)(found) ? witCache && (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n    const isEmpty = (0, _util.isNull)(value);\n    const input = isEmpty || this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value); // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].set(hexKey, value);\n\n    if (meta.modifier.isOptional) {\n      return new _types.Option(registry, (0, _types.createClass)(registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(registry, type, [input], true));\n    }\n\n    return (0, _types.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);\n  }\n\n}\n\nexports.default = Rpc;"]},"metadata":{},"sourceType":"script"}