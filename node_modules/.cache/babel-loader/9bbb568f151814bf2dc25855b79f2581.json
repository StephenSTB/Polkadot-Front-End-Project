{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createClass = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CallIndex = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _create = require(\"../create\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"../codec/U8aFixed\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\n\n\nfunction getArgsDef(registry, meta) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return Call.filterOrigin(meta).reduce(function (result, _ref) {\n    var name = _ref.name,\n        type = _ref.type;\n    var Type = (0, _create.getTypeClass)(registry, (0, _create.getTypeDef)(type.toString()));\n    result[name.toString()] = Type;\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  var args = value.args,\n      callIndex = value.callIndex; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  var lookupIndex = callIndex instanceof CallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  var meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args: args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex: callIndex,\n    meta: meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  var callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  var meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex: callIndex,\n    meta: meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n\n  var _meta = arguments.length > 2 ? arguments[2] : undefined;\n\n  if ((0, _util.isHex)(value) || (0, _util.isU8a)(value)) {\n    return decodeCallViaU8a(registry, (0, _util.u8aToU8a)(value), _meta);\n  } else if ((0, _util.isObject)(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(\"Call: Cannot decode value '\".concat(value, \"' of type \").concat(typeof value));\n}\n/**\n * @name CallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nvar CallIndex = /*#__PURE__*/function (_U8aFixed$default) {\n  _inherits(CallIndex, _U8aFixed$default);\n\n  var _super = _createSuper(CallIndex);\n\n  function CallIndex(registry, value) {\n    _classCallCheck(this, CallIndex);\n\n    return _super.call(this, registry, value, 16);\n  }\n\n  return CallIndex;\n}(_U8aFixed.default);\n/**\n * @name Call\n * @description\n * Extrinsic function descriptor\n */\n\n\nexports.CallIndex = CallIndex;\n\nvar Call = /*#__PURE__*/function (_Struct$default) {\n  _inherits(Call, _Struct$default);\n\n  var _super2 = _createSuper(Call);\n\n  function Call(registry, value, meta) {\n    var _this;\n\n    _classCallCheck(this, Call);\n\n    var decoded = decodeCall(registry, value, meta);\n    _this = _super2.call(this, registry, {\n      callIndex: CallIndex,\n      // eslint-disable-next-line sort-keys\n      args: _Struct.default.with(decoded.argsDef)\n    }, decoded);\n    _this._meta = void 0;\n    _this._meta = decoded.meta;\n    return _this;\n  } // If the extrinsic function has an argument of type `Origin`, we ignore it\n\n\n  _createClass(Call, [{\n    key: \"toHuman\",\n\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    value: function toHuman(isExpanded) {\n      var _call, _call2;\n\n      var call;\n\n      try {\n        call = this.registry.findMetaCall(this.callIndex);\n      } catch (error) {// swallow\n      }\n\n      return _objectSpread({\n        args: this.args.map(function (arg) {\n          return arg.toHuman(isExpanded);\n        }),\n        // args: this.args.map((arg, index) => call\n        //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n        //   : arg.toHuman(isExpanded)\n        // ),\n        // callIndex: u8aToHex(this.callIndex),\n        method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n        section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n      }, isExpanded && call ? {\n        documentation: call.meta.documentation.map(function (d) {\n          return d.toString();\n        })\n      } : {});\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'Call';\n    }\n  }, {\n    key: \"args\",\n\n    /**\n     * @description The arguments for the function call\n     */\n    get: function get() {\n      // FIXME This should return a Struct instead of an Array\n      return _toConsumableArray(this.get('args').values());\n    }\n    /**\n     * @description The argument definitions\n     */\n\n  }, {\n    key: \"argsDef\",\n    get: function get() {\n      return getArgsDef(this.registry, this.meta);\n    }\n    /**\n     * @description The encoded `[sectionIndex, methodIndex]` identifier\n     */\n\n  }, {\n    key: \"callIndex\",\n    get: function get() {\n      return this.get('callIndex').toU8a();\n    }\n    /**\n     * @description The encoded data\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.get('args').toU8a();\n    }\n    /**\n     * @description `true` if the `Origin` type is on the method (extrinsic method)\n     */\n\n  }, {\n    key: \"hasOrigin\",\n    get: function get() {\n      var firstArg = this.meta.args[0];\n      return !!firstArg && firstArg.type.toString() === 'Origin';\n    }\n    /**\n     * @description The [[FunctionMetadata]]\n     */\n\n  }, {\n    key: \"meta\",\n    get: function get() {\n      return this._meta;\n    }\n    /**\n     * @description Returns the name of the method\n     */\n\n  }, {\n    key: \"methodName\",\n    get: function get() {\n      return this.registry.findMetaCall(this.callIndex).method;\n    }\n    /**\n     * @description Returns the name of the method\n     */\n\n  }, {\n    key: \"method\",\n    get: function get() {\n      return this.methodName;\n    }\n    /**\n     * @description Returns the module containing the method\n     */\n\n  }, {\n    key: \"sectionName\",\n    get: function get() {\n      return this.registry.findMetaCall(this.callIndex).section;\n    }\n    /**\n     * @description Returns the module containing the method\n     */\n\n  }, {\n    key: \"section\",\n    get: function get() {\n      return this.sectionName;\n    }\n  }], [{\n    key: \"filterOrigin\",\n    value: function filterOrigin(meta) {\n      // FIXME should be `arg.type !== Origin`, but doesn't work...\n      return meta ? meta.args.filter(function (_ref2) {\n        var type = _ref2.type;\n        return type.toString() !== 'Origin';\n      }) : [];\n    }\n  }]);\n\n  return Call;\n}(_Struct.default);\n\nexports.default = Call;","map":{"version":3,"sources":["/mnt/c/Users/PC/Documents/PolkadotHelloWorld/PolkadotHelloWorld/Front-End-Project/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/generic/Call.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","CallIndex","_defineProperty2","_util","_create","_Struct","_U8aFixed","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","getArgsDef","registry","meta","Call","filterOrigin","reduce","result","name","type","Type","getTypeClass","getTypeDef","toString","decodeCallViaObject","_meta","args","callIndex","lookupIndex","toU8a","findMetaCall","argsDef","decodeCallViaU8a","Uint8Array","set","subarray","decodeCall","isHex","isU8a","u8aToU8a","isObject","Error","decoded","with","isExpanded","_call","_call2","call","error","map","arg","toHuman","method","section","documentation","d","get","values","firstArg","methodName","sectionName"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CallIndex = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _create = require(\"../create\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"../codec/U8aFixed\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return Call.filterOrigin(meta).reduce((result, {\n    name,\n    type\n  }) => {\n    const Type = (0, _create.getTypeClass)(registry, (0, _create.getTypeDef)(type.toString()));\n    result[name.toString()] = Type;\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  const lookupIndex = callIndex instanceof CallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if ((0, _util.isHex)(value) || (0, _util.isU8a)(value)) {\n    return decodeCallViaU8a(registry, (0, _util.u8aToU8a)(value), _meta);\n  } else if ((0, _util.isObject)(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name CallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nclass CallIndex extends _U8aFixed.default {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n\n}\n/**\n * @name Call\n * @description\n * Extrinsic function descriptor\n */\n\n\nexports.CallIndex = CallIndex;\n\nclass Call extends _Struct.default {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n    super(registry, {\n      callIndex: CallIndex,\n      // eslint-disable-next-line sort-keys\n      args: _Struct.default.with(decoded.argsDef)\n    }, decoded);\n    this._meta = void 0;\n    this._meta = decoded.meta;\n  } // If the extrinsic function has an argument of type `Origin`, we ignore it\n\n\n  static filterOrigin(meta) {\n    // FIXME should be `arg.type !== Origin`, but doesn't work...\n    return meta ? meta.args.filter(({\n      type\n    }) => type.toString() !== 'Origin') : [];\n  }\n  /**\n   * @description The arguments for the function call\n   */\n\n\n  get args() {\n    // FIXME This should return a Struct instead of an Array\n    return [...this.get('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n\n\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n\n\n  get callIndex() {\n    return this.get('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n\n\n  get data() {\n    return this.get('args').toU8a();\n  }\n  /**\n   * @description `true` if the `Origin` type is on the method (extrinsic method)\n   */\n\n\n  get hasOrigin() {\n    const firstArg = this.meta.args[0];\n    return !!firstArg && firstArg.type.toString() === 'Origin';\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get methodName() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get method() {\n    return this.methodName;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get sectionName() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get section() {\n    return this.sectionName;\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    var _call, _call2;\n\n    let call;\n\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch (error) {// swallow\n    }\n\n    return _objectSpread({\n      args: this.args.map(arg => arg.toHuman(isExpanded)),\n      // args: this.args.map((arg, index) => call\n      //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n      //   : arg.toHuman(isExpanded)\n      // ),\n      // callIndex: u8aToHex(this.callIndex),\n      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n    }, isExpanded && call ? {\n      documentation: call.meta.documentation.map(d => d.toString())\n    } : {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Call';\n  }\n\n}\n\nexports.default = Call;"]},"metadata":{},"sourceType":"script"}